C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN MAIN.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          
   3          /*************************************************************/
   4          //通信协议 ModBus
   5          //超时40ms      0xAF00
   6          
   7          //本程序适用芯片为：STC89C58RD+
   8          
   9          // 设定压力存储地址     0x8000
  10          // 设定流量存储地址     0x8200~0x8201
  11          // 流量校准参数         0x8600~0x8613
  12          // 流量参数出厂值               Costep[10]
  13          // 压力参数出厂值               P_H
  14          // 
  15          // 本机地址                     0x8400
  16          // 本机序列号           SN[]
  17          // 本机型号                     MODEL[]
  18          // 软件版本号           VERSION[]
  19          // 泵最大压力           MAX_PRESSURE
  20          // 泵最大流量           MAX_FLOW
  21          
  22          
  23          //编写时间　2019-01-10 
  24          /*************************************************************/
  25          
  26          #include <main.h>
  27          #include <stdio.h>
  28          #include <string.h>
  29          
  30          #include "lcd.h"
  31          #include "STC_ISP_RW.h"
  32          #include "pump_AtoB.h"
  33          
  34          #define MODBUSASCII     1
  35          //#define MODBUSRTU     1
  36          
  37          #ifdef MODBUSRTU
              typedef struct _t_modbusRTU {
                      uchar address;
                      uchar funcode;
                      uchar value[50];
                      uchar valuelen;
                      uchar crc[2];
              } t_modbusRTU;
              #endif
  46          #ifdef MODBUSASCII
  47          typedef struct _t_modbusASCII {
  48                  uchar address[2];
  49                  uchar funcode[2];
  50                  uchar value[100];
  51                  uchar valuelen;
  52          } t_modbusASCII;
  53          #endif
  54          
  55          
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 2   

  56          typedef struct _equippara {
  57                  uchar address;
  58                  uchar serialnumber[6];
  59                  uchar model[8];
  60                  uchar version[6];
  61                  
  62                  uint maxpressure;
  63                  uint maxflow;
  64                  uchar pumpstate;
  65          } equippara;
  66          
  67          uchar isrecvFrame = 0;
  68          #ifdef MODBUSRTU
              t_modbusRTU xdata recvFrame;
              t_modbusRTU xdata sendFrame;
              #endif
  72          #ifdef MODBUSASCII
  73          t_modbusASCII xdata recvFrame;
  74          t_modbusASCII xdata sendFrame;
  75          #endif
  76          volatile uchar Com_Buffer[50];
  77          uchar SendBuff[50];                                                                      
  78          volatile uchar recvLen = 0;
  79          uchar sendLen = 0;
  80          uint CRC16(uchar *puchMsgg, uchar usDataLen);
  81          uchar AsciitoHex8(uchar *pBuf);
  82          uint AsciitoHex16(uchar *pBuf);
  83          uchar LRC(uchar* auchMsg,uint usDataLen);
  84          void SendError(uchar no, uchar funcode);
  85          
  86          equippara equip_para;
  87          uint modbus_overtime_ticks = 0; 
  88          volatile uint pressure_loop_times = 0; 
  89          
  90          
  91          uint  set_pressure; //setting pressure
  92          uint   set_flow;        //setting flow
  93          uint   VAL_pnow = 0;
  94          uchar PcFlag;  //上位机发送标志位
  95          
  96          bit RevFlag=0; //下位机接受成功标志位
  97          //bit RunFlag=0; //泵运行标志为
  98          
  99          void Senddata(uchar *p, uchar len);                                               //串口发送协议码
 100          
 101          uchar  KEY_SCAN(void);
 102          uchar  KEY_SCAN_ONE(void);
 103          uchar  TLC549(void);
 104          void   DELAY_NS(uchar n);       //延时
 105                   
 106          void   Disp_contantflow(void);  //恒流泵操作界面显示
 107          uchar  setting_pressure(void);  //设定压力
 108          uint   setting_flow(void);      //设定流量
 109          uint   pnow(void);               //测量压力
 110          void  clear(uchar com,uchar time);//清除显示
 111          void Responsion(uchar funcode, uchar *value);    //应答
 112          
 113          void Menu_Modify(void);
 114          void Menu_Reset(void);
 115          
 116          uchar code curr_p[8]={"当前压力"};
 117          uchar code set_p[8]={"设定压力"};
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 3   

 118          uchar code set_f[8]={"设定流量"};
 119          uchar code ERROR[5]={"ERROR"};
 120          //------------------------------
 121          #define P_H             1410              //压力参数调整
 122          
 123          uchar code SN[] = "012345";
 124          uchar code MODEL[] = "MP1006C  ";
 125          uchar code VERSION[] = "V1.00 ";
 126          #define MAX_PRESSURE    6               //6.0MPa
 127          #define MAX_FLOW                100             //100ml/min
 128          
 129          #if  MAX_FLOW == 200
              uint code Costep[20]={1293,646,431,324,259,216,185,162,144,129,118,108,100,93,86,
                                    81,76,72,68,65,       };            //流量参数调整
              #else
 133          uint code Costep[MAX_FLOW]={12910,6455,4303,3228,2582,2152,1844,1614,1434,1291,         //10
 134          1173,1075,992,921,860,806,759,717,679,645,              //20
 135          614,586,561,537,516,496,478,461,445,430,                //30
 136          417,404,391,380,369,359,349,340,331,323,                //40
 137          315,307,300,293,287,280,274,269,263,258,          //50
 138          253,248,243,239,234,230,226,222,218,215,                //60
 139          211,208,204,201,198,195,192,189,187,184,                //70
 140          181,179,176,174,172,169,167,165,163,161,                //80
 141          159,157,155,153,151,150,148,146,145,143,                //90
 142          142,140,139,137,136,134,133,132,130,129,                //99
 143                                               };           //流量参数调整
 144          #endif
 145          //------------------------------
 146          void main(void)
 147          {
 148   1              uchar i,key;
 149   1              uchar p_limit=0;
 150   1              unsigned long Val_psum = 0;
 151   1              uint Val_pCnts = 0;
 152   1              uint Pressure_loop = 0;
 153   1              uint Show_loop = 0;
 154   1              uint Protect_loop = 0;
 155   1      
 156   1              uchar funcode = 0;
 157   1              
 158   1              equip_para.address = 0x01;
 159   1              sprintf(equip_para.serialnumber, "%s", SN);
 160   1              sprintf(equip_para.model, "%s", MODEL);
 161   1              sprintf(equip_para.version, "%s", VERSION);
 162   1              
 163   1              equip_para.maxpressure = MAX_PRESSURE * 10;
 164   1              if (MAX_FLOW == 100) equip_para.maxflow = 999;
 165   1              else if (MAX_FLOW == 200) equip_para.maxflow = 200;
 166   1              else equip_para.maxflow = MAX_FLOW * 10;
 167   1              equip_para.pumpstate = 0;
 168   1      //-------------------
 169   1              AUXR=0x00;
 170   1      //-------------------
 171   1              // TMOD |= 0x01;
 172   1              TL0 = 0x00;
 173   1              TH0 = 0xCF;
 174   1              TR0 = 1;
 175   1              ET0 = 1;
 176   1      //-------------------
 177   1              TMOD=0x21;                                 //定时器1用作波特率发生器，定时器0方式1用作ModBus超时定时
 178   1              TL1=0xfd;                                  //Rate：9600
 179   1              TH1=0xfd;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 4   

 180   1      #ifdef MODBUSRTU
                      SCON=0xd8;
              #endif
 183   1      #ifdef MODBUSASCII
 184   1              SCON=0x50;
 185   1      #endif
 186   1              PCON=0x00;         //0x50:模式1 0xd8:模式3
 187   1              EA=1;                                      //总中断开启
 188   1              TR1=1;                                     //定时器1中断开启
 189   1              ES=1;                                      //串行中断
 190   1      //------------------------------------------     
 191   1              memset(&recvFrame, 0, sizeof(recvFrame));
 192   1              memset(&sendFrame, 0, sizeof(sendFrame));
 193   1      
 194   1      //--------------------------------------------
 195   1              P2_7=0;
 196   1              LCD_ini();   //液晶初始化
 197   1      
 198   1              Disp_contantflow();  //恒流泵操作界面显示
 199   1      //--------------------------------------------
 200   1        do
 201   1        {       
 202   2                      if (isrecvFrame == 1) {
 203   3                              isrecvFrame = 0;
 204   3                                                                      
 205   3      #ifdef MODBUSASCII
 206   3                              if (recvLen > 0 && ':' == Com_Buffer[0] && 0x0D == Com_Buffer[recvLen - 2] && 0x0A == Com_Buffer[recvLe
             -n - 1] && equip_para.address == AsciitoHex8(&Com_Buffer[1])) {
 207   4                                      if (LRC(&Com_Buffer[1], recvLen - 5) == AsciitoHex8(&Com_Buffer[recvLen - 4])) {
 208   5      //                                      Senddata(Com_Buffer, recvLen);
 209   5                                              switch (funcode = AsciitoHex8(&Com_Buffer[3])) {
 210   6                                                      case 0x2B:
 211   6                                                              recvFrame.valuelen = 6;
 212   6                                                              break;
 213   6                                                      case 0x06:
 214   6                                                      case 0x03:
 215   6                                                      case 0x05:
 216   6                                                      case 0x01:
 217   6                                                              recvFrame.valuelen = 8;
 218   6                                                              break;
 219   6                                                      default:
 220   6                                                              SendError(0x01, funcode);
 221   6                                                              continue;
 222   6                                              }
 223   5                                              memcpy(recvFrame.value, &Com_Buffer[5], recvFrame.valuelen);
 224   5      //                                      Senddata(&recvFrame.address, 1);
 225   5                                              Responsion(funcode, recvFrame.value);
 226   5                                      }
 227   4                              }
 228   3                              recvLen = 0;                    
 229   3                      }
 230   2      #endif
 231   2                
 232   2                      Show_loop++;
 233   2                      if (Show_loop >= 500) { //间隔刷新显示
 234   3                              Show_loop = 0;
 235   3                              //"当前压力"
 236   3                              LCD_WRI(0x80);
 237   3                              for(i=0;i<8;i++)
 238   3                              {            
 239   4                               LCD_WRD(curr_p[i]);
 240   4                              }
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 5   

 241   3              //"设定压力00.0 MPa"
 242   3                              LCD_WRI(0x90);
 243   3                              for(i=0;i<8;i++)
 244   3                              {
 245   4                               LCD_WRD(set_p[i]);
 246   4                              }
 247   3                        
 248   3              //"设定流量00.0ml/m"
 249   3                              LCD_WRI(0x88);
 250   3                              for(i=0;i<8;i++)
 251   3                              {
 252   4                               LCD_WRD(set_f[i]);
 253   4                              }
 254   3                       
 255   3              //------------------------------------   
 256   3              //--------------------------------------
 257   3              // 显示 "00.00MPa"
 258   3                              LCD_WRI(0x84);
 259   3                              LCD_WRD(0x30+VAL_pnow/1000);
 260   3                              LCD_WRD(0x30+(VAL_pnow %1000)/100);
 261   3                              LCD_WRD(0x2E);
 262   3                              LCD_WRD(0x30+VAL_pnow %100/10);
 263   3                              LCD_WRD(0x30+VAL_pnow %10);
 264   3                              LCD_WRD(0x4D);
 265   3                              LCD_WRD(0x50);
 266   3                              LCD_WRD(0x61);
 267   3              //----------------------------------------
 268   3                              LCD_WRI(0x94);
 269   3                              LCD_WRD(0x30+set_pressure/100);
 270   3                              LCD_WRD(0x30+set_pressure%100/10);
 271   3                              LCD_WRD(0x2E);
 272   3                              LCD_WRD(0x30+set_pressure%10);
 273   3                              LCD_WRI(0x96);
 274   3                              LCD_WRD(0x20);
 275   3                              LCD_WRD(0x4D);
 276   3                              LCD_WRD(0x50);
 277   3                              LCD_WRD(0x61);
 278   3              //-----------------------------------------
 279   3                              LCD_WRI(0x8c);
 280   3                              // LCD_WRD(0x30+set_flow/1000);
 281   3                              LCD_WRD(0x30+set_flow%1000/100);
 282   3                              LCD_WRD(0x30+set_flow%100/10);
 283   3                              if (MAX_FLOW != 200) LCD_WRD(0x2E);
 284   3                              LCD_WRD(0x30+set_flow%10);
 285   3                              //  LCD_WRI(0x8E);
 286   3                              LCD_WRD(0x6D);
 287   3                              LCD_WRD(0x6C);
 288   3                              LCD_WRD(0x2F);
 289   3                              LCD_WRD(0x6D);
 290   3                      }
 291   2      
 292   2      //---------------------------------------
 293   2      //----------------------------------------
 294   2                      key=KEY_SCAN_ONE();
 295   2                      switch(key)
 296   2                      {
 297   3                              case 10:
 298   3                                      Menu_Modify();
 299   3                                      break;
 300   3                              case 11:
 301   3                                      Menu_Reset();
 302   3                                      break;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 6   

 303   3                              case 13:            
 304   3                                      set_pressure=setting_pressure();
 305   3                                      break;
 306   3                              case 12:            
 307   3                                      set_flow=setting_flow();
 308   3                                      break;
 309   3                              case 14:
 310   3                                      Pump_stop();
 311   3                                      equip_para.pumpstate = 0;
 312   3                                      break;
 313   3                              case 15: 
 314   3                                      Pump_run();
 315   3                                      equip_para.pumpstate = 1;
 316   3                                      break;
 317   3                      }
 318   2      //------------------------------------------
 319   2      //----------------------------------
 320   2      //-----------------------------------
 321   2      //计算当前压力
 322   2                      Pressure_loop++;                
 323   2                      if (Pressure_loop >= 100) {
 324   3                              Pressure_loop = 0;
 325   3                              Val_psum += pnow();     
 326   3                              Val_pCnts++;
 327   3                              if (Val_pCnts >= 50) {
 328   4                                      VAL_pnow = Val_psum/Val_pCnts;
 329   4                                      Val_psum = 0;
 330   4                                      Val_pCnts = 0;
 331   4                              }
 332   3                      }
 333   2                      
 334   2       //--------------------------------------------
 335   2      //压力保护
 336   2                      if(equip_para.pumpstate == 1) {
 337   3                              if (p_limit == 1) Protect_loop++;
 338   3                              if(p_limit == 0 && VAL_pnow/10>set_pressure) {
 339   4                                      Pump_stop();
 340   4                                      p_limit=1;
 341   4                              } else if(p_limit==1 && Protect_loop >= 10000) {
 342   4                                      Pump_run();
 343   4                                      p_limit=0;
 344   4                                      Protect_loop = 0;
 345   4                              } 
 346   3                      }
 347   2      //              for(i=100;i<0;i--); 
 348   2              }while(1);
 349   1      
 350   1      }
 351          
 352          //******************************************************************/
 353          //测量当前压力
 354          uint pnow(void)
 355            {
 356   1         uchar AD_val;
 357   1         unsigned long  Val_ptem;
 358   1         uint Val_ptemint;
 359   1       
 360   1         AD_val=TLC549();
 361   1      //-------------------------
 362   1      //软件校零
 363   1         if(AD_val>3)
 364   1         AD_val=AD_val-3;       
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 7   

 365   1         else
 366   1         AD_val=0;
 367   1      //-------------------------
 368   1         Val_ptem=AD_val;
 369   1         Val_ptem*=P_H;        //比例系数
 370   1         Val_ptemint=Val_ptem/255;
 371   1      //--------------------------------
 372   1         return(Val_ptemint);
 373   1        }      
 374          /*****************************************************************/
 375          /******压力设定函数********************/
 376          uchar  setting_pressure(void)
 377             {
 378   1          uchar i;
 379   1          uchar ptime,val_setp;
 380   1              uint p_val;
 381   1              ptime=0;
 382   1              p_val=0;
 383   1      //--------------------
 384   1      //   astring[2]=0; //使PC指令无效
 385   1      //--------------------
 386   1      //显示"Pset"
 387   1          LCD_WRI(0x98);
 388   1              LCD_WRD(0x50);
 389   1              LCD_WRD(0x73);
 390   1              LCD_WRD(0x65);
 391   1              LCD_WRD(0x74);
 392   1      //--------------------
 393   1          LCD_WRI(0x94);
 394   1              LCD_WRD(0x20);
 395   1              LCD_WRD(0x20);
 396   1              LCD_WRD(0x20);
 397   1              LCD_WRD(0x20);
 398   1              LCD_WRI(0x94);
 399   1      //---------------------
 400   1         while(ptime<=2)
 401   1             {
 402   2                  val_setp=KEY_SCAN();
 403   2                      if(val_setp<10)
 404   2                              {
 405   3                                LCD_WRD(0x30+val_setp);
 406   3                               switch (ptime)
 407   3                                 {
 408   4                                  case 0:
 409   4                                      p_val=p_val+val_setp*100;
 410   4                                      break;
 411   4                                      case 1:
 412   4                                      p_val=p_val+val_setp*10;
 413   4                                      LCD_WRD(0x2E);
 414   4                                      break;
 415   4                                      case 2:
 416   4                                      p_val=p_val+val_setp*1;
 417   4                                      break;
 418   4                                 }
 419   3                                ptime++;
 420   3                              }
 421   2                  }
 422   1      //----------------------------
 423   1              if(p_val<=equip_para.maxpressure)
 424   1              { set_pressure=p_val;
 425   2               EEPROM_sector_erase(0x8000);
 426   2               EEPROM_byte_program(0x8000,set_pressure >> 8); //记忆设定值
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 8   

 427   2               EEPROM_byte_program(0x8001,set_pressure & 0x00FF); //记忆设定值
 428   2                clear(0x98,5);
 429   2      //---------------------------
 430   2      /*
 431   2           Com_Buffer[0]='0';
 432   2               Com_Buffer[1]='0';
 433   2               Com_Buffer[2]='P';
 434   2               Com_Buffer[3]=0x30+set_pressure/100;
 435   2               Com_Buffer[4]=0x30+set_pressure%100/10;
 436   2               Com_Buffer[5]='.';
 437   2               Com_Buffer[6]=0x30+set_pressure%10;
 438   2               Senddata_pc(Com_Buffer);
 439   2      */       
 440   2      //---------------------------
 441   2               }
 442   1               else 
 443   1                  { LCD_WRI(0x98);
 444   2                   for(i=0;i<=4;i++)
 445   2                       LCD_WRD(ERROR[i]);
 446   2                       }
 447   1      //------------------------------
 448   1          return(set_pressure);  
 449   1         }
 450          /***************************************************************/
 451          /**************设定流量函数******************/
 452          uint   setting_flow(void)
 453           {
 454   1          uchar i;
 455   1          uchar ptime,val_setp;
 456   1              uint p_val;
 457   1              ptime=0;
 458   1              p_val=0;
 459   1      //--------------------
 460   1      //   astring[2]=0; //使PC指令无效
 461   1      //--------------------
 462   1      //显示"Lset"
 463   1          LCD_WRI(0x98);
 464   1              LCD_WRD(0x4C);
 465   1              LCD_WRD(0x73);
 466   1              LCD_WRD(0x65);
 467   1              LCD_WRD(0x74);
 468   1      //--------------------
 469   1      //--------------------
 470   1          LCD_WRI(0x8C);
 471   1              LCD_WRD(0x20);
 472   1              LCD_WRD(0x20);
 473   1              LCD_WRD(0x20);
 474   1              LCD_WRD(0x20);
 475   1              LCD_WRI(0x8C);
 476   1      //---------------------
 477   1         while(ptime<=2)
 478   1             {
 479   2              val_setp=KEY_SCAN();
 480   2                    if(val_setp<10)
 481   2                              {
 482   3                                LCD_WRD(0x30+val_setp);
 483   3                                switch (ptime)
 484   3                                 {
 485   4                                  case 0:
 486   4                                      p_val=p_val+val_setp*100;
 487   4                                      break;
 488   4                                      case 1:
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 9   

 489   4                                      p_val=p_val+val_setp*10;
 490   4                                      if (MAX_FLOW != 200) LCD_WRD(0x2E);
 491   4                                      break;
 492   4                                      case 2:
 493   4                                      p_val=p_val+val_setp*1;
 494   4                                      break;
 495   4                              //      case 3:
 496   4                              //      p_val=p_val+val_setp*1;
 497   4                              //      break;
 498   4                                 }
 499   3                                ptime++;
 500   3                              }
 501   2                  }
 502   1      //----------------------------
 503   1              if(p_val<=equip_para.maxflow)
 504   1              { 
 505   2               set_flow=p_val;         
 506   2               EEPROM_sector_erase(0x8200);
 507   2               EEPROM_byte_program(0x8200,set_flow>>8); //记忆设定值
 508   2               EEPROM_byte_program(0x8201,set_flow&0x00FF); //记忆设定值
 509   2      
 510   2           Pump_flow(set_flow);       
 511   2               clear(0x98,5);
 512   2      //----------------------------------------
 513   2               }
 514   1               else 
 515   1                  { LCD_WRI(0x98);
 516   2                   for(i=0;i<=4;i++)
 517   2                       LCD_WRD(ERROR[i]);
 518   2                       }
 519   1      //------------------------------
 520   1          return(set_flow);  
 521   1       }
 522          //****************************************************************/
 523          void clear( uchar com,uchar time)
 524            {
 525   1        uchar i;
 526   1        LCD_WRI(com);
 527   1        for(i=0;i<=time;i++)
 528   1        LCD_WRD(0x20);
 529   1        }
 530          //*********************************************************************
 531          // 恒流泵操作界面显示 子函数
 532          void   Disp_contantflow(void)
 533          {
 534   1              uchar i;
 535   1         //------------------------------------
 536   1       //"当前压力"
 537   1              LCD_WRI(0x80);
 538   1              for(i=0;i<8;i++) {           
 539   2                      LCD_WRD(curr_p[i]);
 540   2              }
 541   1      //"设定压力00.0 MPa"
 542   1              LCD_WRI(0x90);
 543   1              for(i=0;i<8;i++) {
 544   2                      LCD_WRD(set_p[i]);
 545   2              }
 546   1              LCD_WRI(0x96);
 547   1              LCD_WRD(0x20);
 548   1              LCD_WRD(0x4D);
 549   1              LCD_WRD(0x50);
 550   1              LCD_WRD(0x61);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 10  

 551   1      //"设定流量00.0ml/m"
 552   1              LCD_WRI(0x88);
 553   1              for(i=0;i<8;i++) {
 554   2                      LCD_WRD(set_f[i]);
 555   2              }
 556   1              LCD_WRI(0x8E);
 557   1              LCD_WRD(0x6D);
 558   1              LCD_WRD(0x6C);
 559   1              LCD_WRD(0x2F);
 560   1              LCD_WRD(0x6D);
 561   1      //------------------------------------
 562   1      //"00.0" 显示压力
 563   1              LCD_WRI(0x94);
 564   1              set_pressure=EEPROM_byte_read(0x8000) << 8;
 565   1              set_pressure|=EEPROM_byte_read(0x8001);
 566   1              if (set_pressure == 0 || set_pressure > equip_para.maxpressure) {
 567   2                      set_pressure = equip_para.maxpressure;
 568   2                      EEPROM_sector_erase(0x8000);
 569   2                      EEPROM_byte_program(0x8000,set_pressure >> 8); //记忆设定值
 570   2                      EEPROM_byte_program(0x8001,set_pressure & 0x00FF); //记忆设定值
 571   2              }
 572   1              LCD_WRD(0x30+set_pressure/100);    
 573   1              LCD_WRD(0x30+(set_pressure %100)/10);
 574   1              LCD_WRD(0x2E);
 575   1              LCD_WRD(0x30+set_pressure %10);
 576   1      //------------------------------------
 577   1      //"000"显示流量
 578   1              LCD_WRI(0x8C);
 579   1              set_flow=EEPROM_byte_read(0x8200)<<8;
 580   1              set_flow|=EEPROM_byte_read(0x8201);
 581   1              if (set_flow == 0 || set_flow > equip_para.maxflow) {
 582   2                      set_flow = equip_para.maxflow;
 583   2                      EEPROM_sector_erase(0x8200);
 584   2                      EEPROM_byte_program(0x8200,set_flow>>8); //记忆设定值
 585   2                      EEPROM_byte_program(0x8201,set_flow&0x00FF); //记忆设定值
 586   2              }
 587   1      //  LCD_WRD(0x30+set_flow/1000);
 588   1              LCD_WRD(0x30+set_flow%1000/100);
 589   1              LCD_WRD(0x30+(set_flow %100)/10);
 590   1              if (MAX_FLOW != 200) LCD_WRD(0x2E);
 591   1              LCD_WRD(0x30+set_flow %10);
 592   1      //------------------------------------
 593   1      //显示"STOP"
 594   1              LCD_WRI(0x9E);
 595   1              LCD_WRD(0x53);
 596   1              LCD_WRD(0x54);
 597   1              LCD_WRD(0x4F);
 598   1              LCD_WRD(0x50);
 599   1      //------------------------------------ 
 600   1              equip_para.address = EEPROM_byte_read(0x8400);
 601   1              if (equip_para.address == 0x00 || equip_para.address > 32) {
 602   2                      equip_para.address = 0x01;
 603   2                      EEPROM_sector_erase(0x8400);
 604   2                      EEPROM_byte_program(0x8400, equip_para.address); //记忆本机地址
 605   2              }
 606   1      //------------------------------------ 
 607   1              DELAY_NS(1);  
 608   1              Pump_flow(set_flow);
 609   1      }
 610          //******************************************************************
 611          //流量调整界面
 612           void Menu_Modify(void)
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 11  

 613            {
 614   1          uchar i,key,ptime=0,segment=0;
 615   1              uint Mfset=0,Mfmea=0,Mdata;
 616   1              uint EEPROM_dir=0x8600,EEPROM_data;
 617   1              uint Flow_tem[10];
 618   1              unsigned long multi;
 619   1      
 620   1              uchar code Disp_Mtitle[8]={"调整流量"};
 621   1              uchar code Disp_Mfset[8]={"设定流量"};
 622   1              uchar code Disp_Mfmea[8]={"测定流量"};
 623   1              uchar code Disp_write[10]={"调整值写入"};
 624   1              uchar code Disp_cancel[14]={"调整值写入取消"};
 625   1              uchar code Disp_cuowu[4]={"错误"};
 626   1              uchar code Disp_promt1[12]={"调整值必须为"};
 627   1              uchar code Disp_promt2[10]={"10的整  倍"};
 628   1              //,0xca,0xfd,
 629   1      
 630   1              EA=0;
 631   1      
 632   1              LCD_WRI(0x01);
 633   1              for(i=255;i<0;i--);
 634   1      //-------------------------
 635   1       if(set_flow%10!=0)
 636   1         {
 637   2           LCD_WRI(0x80);
 638   2                for(i=0;i<4;i++)
 639   2                {          
 640   3                      LCD_WRD(Disp_cuowu[i]);
 641   3                 }
 642   2               LCD_WRI(0x90);
 643   2                for(i=0;i<12;i++)
 644   2                {          
 645   3                      LCD_WRD(Disp_promt1[i]);
 646   3                 }
 647   2                LCD_WRI(0x88);
 648   2                for(i=0;i<10;i++)
 649   2                {          
 650   3                      LCD_WRD(Disp_promt2[i]);
 651   3                 }
 652   2                LCD_WRI(0x8b);
 653   2                LCD_WRD(0xca);
 654   2                LCD_WRD(0xfd);
 655   2                DELAY_NS(2);
 656   2      //-----------------------------
 657   2           LCD_WRI(0x01);
 658   2               for(i=255;i<0;i--);  
 659   2               Disp_contantflow();
 660   2      
 661   2               EA=1;
 662   2      //------------------------------  
 663   2              return;
 664   2         }
 665   1      
 666   1      //------------------------------
 667   1               LCD_WRI(0x82);
 668   1               for(i=0;i<8;i++)
 669   1               {           
 670   2                      LCD_WRD(Disp_Mtitle[i]);
 671   2               }
 672   1               LCD_WRI(0x90);
 673   1               for(i=0;i<8;i++)
 674   1               {           
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 12  

 675   2                      LCD_WRD(Disp_Mfset[i]);
 676   2               }
 677   1                LCD_WRI(0x88);
 678   1               for(i=0;i<8;i++)
 679   1               {           
 680   2                      LCD_WRD(Disp_Mfmea[i]);
 681   2               }
 682   1      
 683   1      //----------------------------------
 684   1            LCD_WRI(0x95);
 685   1                LCD_WRD(0x30+set_flow/100);
 686   1            LCD_WRD(0x30+set_flow%100/10);
 687   1                if (MAX_FLOW != 200) LCD_WRD(0x2E);
 688   1                LCD_WRD(0x30+set_flow%10);
 689   1      
 690   1                 LCD_WRI(0x8d);
 691   1                while(ptime<=3)
 692   1             {
 693   2              key=KEY_SCAN();
 694   2                             if(key==14)
 695   2                                   {
 696   3                                        goto FModifyEnd;
 697   3                                       }
 698   2                    if(key<10)
 699   2                              {
 700   3                                LCD_WRD(0x30+key);
 701   3                                switch (ptime)
 702   3                                 {
 703   4                                  case 0:
 704   4                                      Mfmea=key*1000;
 705   4                                      break;
 706   4                                      case 1:
 707   4                                  Mfmea=Mfmea+key*100;
 708   4                                  LCD_WRD(0x2E);
 709   4                                      break;
 710   4                                      case 2:
 711   4                                      Mfmea=Mfmea+key*10;
 712   4                                      
 713   4                                      break;
 714   4                                      case 3:
 715   4                                      Mfmea=Mfmea+key;
 716   4                                      break;
 717   4                                 }
 718   3                                      
 719   3                                ptime++;
 720   3                              }
 721   2                        if(key==12)
 722   2                         {
 723   3                          LCD_WRI(0x8d);
 724   3                              LCD_WRD(0x20); 
 725   3                          LCD_WRD(0x20);
 726   3                              LCD_WRD(0x20);
 727   3                              LCD_WRD(0x20);
 728   3                              LCD_WRD(0x20);
 729   3                              LCD_WRD(0x20);
 730   3                              LCD_WRI(0x8d);
 731   3                              ptime=0;
 732   3                              Mfmea=0;
 733   3                         }
 734   2                  }
 735   1      //----------------------------------
 736   1       //从EEPROM里读出参数值存储在step数组里
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 13  

 737   1      #if MAX_FLOW == 200
                      for (i=0;i<20;i++)
              #else
 740   1              for (i=0;i<MAX_FLOW;i++)
 741   1      #endif
 742   1               {
 743   2              // EEPROM_dir=EEPROM_dir+i*2;
 744   2               EEPROM_dir=0x8600+i*2;
 745   2           EEPROM_data=EEPROM_byte_read(EEPROM_dir)<<8;
 746   2               EEPROM_data=EEPROM_data+EEPROM_byte_read(EEPROM_dir+1);
 747   2               Flow_tem[i]=EEPROM_data;
 748   2               } 
 749   1      //----------------------------------
 750   1           if(set_flow>=1)
 751   1           segment=(set_flow-1)/10;
 752   1           else
 753   1           segment=0;
 754   1      
 755   1           Mfset=set_flow*10;
 756   1      
 757   1      
 758   1           multi=Flow_tem[segment];
 759   1           multi=multi*Mfmea;
 760   1               Mdata=multi/Mfset;
 761   1              Flow_tem[segment]=Mdata;
 762   1      
 763   1            LCD_WRI(0x98);
 764   1                LCD_WRD(0x30+Mdata/10000);
 765   1                LCD_WRD(0x30+Mdata%10000/1000);
 766   1            LCD_WRD(0x30+Mdata%1000/100);
 767   1                LCD_WRD(0x30+Mdata%100/10);
 768   1                LCD_WRD(0x30+Mdata%10);
 769   1      /*
 770   1                LCD_WRD(0x30+Mfmea/1000);
 771   1            LCD_WRD(0x30+Mfmea%1000/100);
 772   1                LCD_WRD(0x30+Mfmea%100/10);
 773   1                LCD_WRD(0x30+Mfmea%10);
 774   1      
 775   1                LCD_WRD(0x30+Mfset/1000);
 776   1            LCD_WRD(0x30+Mfset%1000/100);
 777   1                LCD_WRD(0x30+Mfset%100/10);
 778   1                LCD_WRD(0x30+Mfset%10);
 779   1        */
 780   1         do
 781   1         {
 782   2            key=KEY_SCAN();
 783   2                if(key==15)
 784   2                {
 785   3      //----------------------------------
 786   3      //参数值写进EEPROM
 787   3           EEPROM_sector_erase(0x8600);
 788   3      #if MAX_FLOW == 200
                      for (i=0;i<20;i++)
              #else
 791   3              for (i=0;i<MAX_FLOW;i++)
 792   3      #endif   
 793   3              {
 794   4               EEPROM_dir=0x8600+i*2;
 795   4               EEPROM_data=Flow_tem[i];
 796   4               EEPROM_byte_program(EEPROM_dir,EEPROM_data>>8); //记忆设定值
 797   4               EEPROM_byte_program(EEPROM_dir+1,EEPROM_data&0x00FF); //记忆设定值
 798   4      
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 14  

 799   4               }
 800   3      //------------------------------------
 801   3              LCD_WRI(0x98);
 802   3                  for(i=0;i<10;i++)
 803   3                  {        
 804   4                      LCD_WRD(Disp_write[i]);
 805   4                   }
 806   3                       DELAY_NS(2);
 807   3               key=20;
 808   3      //----------------------------------
 809   3                }
 810   2      
 811   2      //-------------------------------------
 812   2           if(key==14)
 813   2               {
 814   3                  LCD_WRI(0x98);
 815   3                  for(i=0;i<14;i++)
 816   3                  {        
 817   4                      LCD_WRD(Disp_cancel[i]);
 818   4                   }
 819   3                       DELAY_NS(5);
 820   3               key=20; 
 821   3               }
 822   2      //-------------------------------------
 823   2         }while(key!=20);    
 824   1      //----------------------------------
 825   1      FModifyEnd:
 826   1      
 827   1           LCD_WRI(0x01);
 828   1               for(i=255;i<0;i--);  
 829   1               Disp_contantflow();
 830   1      
 831   1               EA=1;
 832   1        }
 833          /**************************************************************************/
 834          void Menu_Reset(void)
 835            {
 836   1           uchar i,key;
 837   1           uint EEPROM_dir=0x8600,EEPROM_data;
 838   1               uchar code Reset_title[10]={"出厂值恢复"};
 839   1               uchar code Reset_ok[6]={"确定R "};
 840   1               uchar code Reset_cancel[6]={"取消S "};
 841   1               uchar code Disp_resetok[14]={"出厂值恢复成功"};
 842   1               uchar code Disp_resetnot[14]={"出厂值恢复取消"};
 843   1      //------------------------------------------
 844   1                      LCD_WRI(0x01);
 845   1                     for(i=255;i<0;i--);
 846   1      //-----------------------------------------
 847   1                  LCD_WRI(0x92);
 848   1                  for(i=0;i<10;i++)
 849   1                  {        
 850   2                      LCD_WRD(Reset_title[i]);
 851   2                   }
 852   1              LCD_WRI(0x98);
 853   1                  for(i=0;i<6;i++)
 854   1                  {        
 855   2                      LCD_WRD(Reset_ok[i]);
 856   2                   }
 857   1                      LCD_WRI(0x9d);
 858   1                  for(i=0;i<6;i++)
 859   1                  {        
 860   2                      LCD_WRD(Reset_cancel[i]);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 15  

 861   2                   }
 862   1         do
 863   1         {
 864   2                 key=KEY_SCAN();
 865   2                 if(key==15)
 866   2                  {
 867   3      //参数值写进EEPROM
 868   3                    EEPROM_sector_erase(0x8600);
 869   3                              #if MAX_FLOW == 200
                                    for (i=0;i<20;i++)
                                      #else
 872   3                                              for (i=0;i<MAX_FLOW;i++)
 873   3                              #endif
 874   3                           {
 875   4                             EEPROM_dir=0x8600+i*2;
 876   4                             EEPROM_data=Costep[i];
 877   4                             EEPROM_byte_program(EEPROM_dir,EEPROM_data>>8); //记忆设定值
 878   4                             EEPROM_byte_program(EEPROM_dir+1,EEPROM_data&0x00FF); //记忆设定值
 879   4                            } 
 880   3                 LCD_WRI(0x01);
 881   3                     for(i=255;i<0;i--);
 882   3                         LCD_WRI(0x90);
 883   3                     for(i=0;i<14;i++)
 884   3                     {             
 885   4                          LCD_WRD(Disp_resetok[i]);
 886   4                     }
 887   3                         DELAY_NS(5);
 888   3                          key=21;
 889   3                      }
 890   2      
 891   2                      if(key==14)
 892   2                      {
 893   3                         LCD_WRI(0x01);
 894   3                     for(i=255;i<0;i--);
 895   3                         LCD_WRI(0x90);
 896   3                     for(i=0;i<14;i++)
 897   3                     {             
 898   4                          LCD_WRD(Disp_resetnot[i]);
 899   4                     }
 900   3                         DELAY_NS(5);
 901   3                       key=21;
 902   3                      }
 903   2      
 904   2              }while(key!=21);
 905   1      
 906   1               LCD_WRI(0x01);
 907   1               for(i=255;i<0;i--);  
 908   1               Disp_contantflow();
 909   1      
 910   1        }
 911          //******************************************************************
 912          void Responsion(uchar funcode, uchar *value)
 913          {
 914   1              uchar lrc_ret[2] = 0;
 915   1              uchar i = 0;
 916   1      
 917   1              uint reg_address = 0;
 918   1              uint reg_value = 0;
 919   1              
 920   1              switch (funcode) {
 921   2                      case 0x2B:
 922   2                              //check legality
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 16  

 923   2                              if (strstr(value, "0E0100") == NULL) return;
 924   2                              //make response
 925   2                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
 926   2                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
 927   2                              sendFrame.valuelen = 44;
 928   2                              memcpy(sendFrame.value, "0E01010000030006", 16); i+= 16;
 929   2                              memcpy(sendFrame.value + i, equip_para.serialnumber, sizeof(equip_para.serialnumber)); i += sizeof(equi
             -p_para.serialnumber);
 930   2                              memcpy(sendFrame.value + i, "0108", 4); i+= 4;
 931   2                              memcpy(sendFrame.value + i, equip_para.model, sizeof(equip_para.model)); i += sizeof(equip_para.model);
 932   2                              memcpy(sendFrame.value + i, "0206", 4); i+= 4;
 933   2                              memcpy(sendFrame.value + i, equip_para.version, sizeof(equip_para.version)); i += sizeof(equip_para.ver
             -sion);
 934   2                              SendBuff[0] = ':';
 935   2                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
 936   2                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
 937   2                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
 938   2                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
 939   2                              Senddata(SendBuff, sendLen);
 940   2                              //do something
 941   2                              break;
 942   2                      case 0x06:              
 943   2                              reg_address = AsciitoHex16(&value[0]);
 944   2                              reg_value = AsciitoHex16(&value[4]);
 945   2                              if (reg_address == 0x0001) {
 946   3                                      if (reg_value > 0 && reg_value <= 32) {
 947   4                                              if (equip_para.address != reg_value) {
 948   5                                                      //do something
 949   5                                                      EEPROM_sector_erase(0x8400);
 950   5                                                      EEPROM_byte_program(0x8400, (uchar)reg_value); //记忆本机地址   
 951   5                                                      //make response
 952   5                                                      sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
 953   5                                                      sprintf(sendFrame.funcode, "%02X", (uint)funcode);
 954   5                                                      sendFrame.valuelen = 8;
 955   5                                                      sprintf(sendFrame.value, "0001");
 956   5                                                      sprintf(sendFrame.value + 4, "%04X", (uint)reg_value);
 957   5                                                      SendBuff[0] = ':';
 958   5                                                      memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
 959   5                                                      sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
 960   5                                                      memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
 961   5                                                      memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
 962   5                                                      Senddata(SendBuff, sendLen);
 963   5                                                      //do something
 964   5                                                      equip_para.address = (uchar)reg_value;
 965   5                                              }       
 966   4                                      } else {
 967   4                                              SendError(0x03, funcode); return;
 968   4                                      }
 969   3                              } else if (reg_address == 0x0002) {
 970   3                                      if (reg_value > 0 && reg_value <= equip_para.maxpressure) {
 971   4                                              //do something
 972   4                                              set_pressure = reg_value;
 973   4                                              EEPROM_sector_erase(0x8000);
 974   4                                              EEPROM_byte_program(0x8000,set_pressure >> 8);
 975   4                                              EEPROM_byte_program(0x8001,set_pressure & 0x00FF);
 976   4                                              //make response
 977   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
 978   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
 979   4                                              sendFrame.valuelen = 8;
 980   4                                              sprintf(sendFrame.value, "0002");
 981   4                                              sprintf(sendFrame.value + 4, "%04X", (uint)set_pressure);
 982   4                                              SendBuff[0] = ':';
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 17  

 983   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
 984   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
 985   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
 986   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
 987   4                                              Senddata(SendBuff, sendLen);
 988   4                                      } else {
 989   4                                              SendError(0x03, funcode); return;
 990   4                                      }
 991   3                              } else if (reg_address == 0x0003) {
 992   3                                      if (reg_value > 0 && reg_value <= equip_para.maxflow) {
 993   4                                              //do something
 994   4                                              set_flow = reg_value;
 995   4                                              EEPROM_sector_erase(0x8200);
 996   4                                              EEPROM_byte_program(0x8200,set_flow>>8);
 997   4                                              EEPROM_byte_program(0x8201,set_flow&0x00FF);
 998   4                                              Pump_flow(set_flow);
 999   4                                              //make response
1000   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1001   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
1002   4                                              sendFrame.valuelen = 8;
1003   4                                              sprintf(sendFrame.value, "0003");
1004   4                                              sprintf(sendFrame.value + 4, "%04X", (uint)set_flow);
1005   4                                              SendBuff[0] = ':';
1006   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1007   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1008   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1009   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1010   4                                              Senddata(SendBuff, sendLen);
1011   4                                      } else {
1012   4                                              SendError(0x03, funcode); return;
1013   4                                      }
1014   3                              } else {
1015   3                                      SendError(0x02, funcode); return;
1016   3                              }                       
1017   2                              break;
1018   2                      case 0x03:
1019   2                              reg_address = AsciitoHex16(&value[0]);
1020   2                              reg_value = AsciitoHex16(&value[4]);
1021   2                              if (reg_address == 0x0002) {
1022   3                                      if (reg_value == 0x0001) {
1023   4                                              //do something
1024   4                                              //make response
1025   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1026   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
1027   4                                              sendFrame.valuelen = 6;
1028   4                                              sprintf(sendFrame.value, "02");
1029   4                                              sprintf(sendFrame.value + 2, "%04X", (uint)set_pressure);
1030   4                                              SendBuff[0] = ':';
1031   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1032   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1033   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1034   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1035   4                                              Senddata(SendBuff, sendLen);
1036   4                                      } else {
1037   4                                              SendError(0x03, funcode); return;
1038   4                                      }
1039   3                              } else if (reg_address == 0x0003) {
1040   3                                      if (reg_value == 0x0001) {
1041   4                                              //do something
1042   4                                              //make response
1043   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1044   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 18  

1045   4                                              sendFrame.valuelen = 6;
1046   4                                              sprintf(sendFrame.value, "02");
1047   4                                              sprintf(sendFrame.value + 2, "%04X", (uint)set_flow);
1048   4                                              SendBuff[0] = ':';
1049   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1050   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1051   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1052   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1053   4                                              Senddata(SendBuff, sendLen);
1054   4                                      } else {
1055   4                                              SendError(0x03, funcode); return;
1056   4                                      }
1057   3                              } else if (reg_address == 0x0004) {
1058   3                                      if (reg_value == 0x0001) {
1059   4                                              //do something
1060   4                                              //make response
1061   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1062   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
1063   4                                              sendFrame.valuelen = 6;
1064   4                                              sprintf(sendFrame.value, "02");
1065   4                                              sprintf(sendFrame.value + 2, "%04X", (uint)(VAL_pnow / 10));
1066   4                                              SendBuff[0] = ':';
1067   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1068   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1069   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1070   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1071   4                                              Senddata(SendBuff, sendLen);
1072   4                                      } else {
1073   4                                              SendError(0x03, funcode); return;
1074   4                                      }
1075   3                              } else {
1076   3                                      SendError(0x02, funcode); return;
1077   3                              }
1078   2                              break;
1079   2                      case 0x05:
1080   2                              reg_address = AsciitoHex16(&value[0]);
1081   2                              reg_value = AsciitoHex16(&value[4]);
1082   2                              if (reg_address == 0x0001) {
1083   3                                      if (reg_value == 0xff00) {
1084   4                                              //do something
1085   4                                              Pump_run();
1086   4                                              equip_para.pumpstate = 1;
1087   4                                              //make response
1088   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1089   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
1090   4                                              sendFrame.valuelen = 8;
1091   4                                              sprintf(sendFrame.value, "0001");
1092   4                                              sprintf(sendFrame.value + 4, "FF00");
1093   4                                              SendBuff[0] = ':';
1094   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1095   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1096   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1097   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1098   4                                              Senddata(SendBuff, sendLen);
1099   4                                      } else if (reg_value == 0x0000) {
1100   4                                              //do something
1101   4                                              Pump_stop();
1102   4                                              equip_para.pumpstate = 0;
1103   4                                              //make response
1104   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1105   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
1106   4                                              sendFrame.valuelen = 8;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 19  

1107   4                                              sprintf(sendFrame.value, "0001");
1108   4                                              sprintf(sendFrame.value + 4, "0000");
1109   4                                              SendBuff[0] = ':';
1110   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1111   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1112   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1113   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1114   4                                              Senddata(SendBuff, sendLen);
1115   4                                      } else {
1116   4                                              SendError(0x03, funcode); return;
1117   4                                      }
1118   3                              } else {
1119   3                                      SendError(0x02, funcode); return;
1120   3                              }                       
1121   2                              break;
1122   2                      case 0x01:
1123   2                              reg_address = AsciitoHex16(&value[0]);
1124   2                              reg_value = AsciitoHex16(&value[4]);
1125   2                              if (reg_address == 0x0001) {
1126   3                                      if (reg_value == 0x0001) {
1127   4                                              //do something
1128   4                                              //make response
1129   4                                              sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1130   4                                              sprintf(sendFrame.funcode, "%02X", (uint)funcode);
1131   4                                              sendFrame.valuelen = 4;
1132   4                                              sprintf(sendFrame.value, "01");
1133   4                                              sprintf(sendFrame.value + 2, "%02X", (uint)equip_para.pumpstate);
1134   4                                              SendBuff[0] = ':';
1135   4                                              memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1136   4                                              sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1137   4                                              memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1138   4                                              memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1139   4                                              Senddata(SendBuff, sendLen);
1140   4                                      } else {
1141   4                                              SendError(0x03, funcode); return;
1142   4                                      }
1143   3                              } else {
1144   3                                      SendError(0x02, funcode); return;
1145   3                              }                       
1146   2                              break;
1147   2              }
1148   1              
1149   1               
1150   1      }
1151          //******************************************************************
1152          void serial(void) interrupt 4                                            //串口中断接收
1153          {
1154   1              if(RI) {
1155   2                      RI = 0;
1156   2      #ifdef MODBUSRTU
                              Com_Buffer[recvLen++]=SBUF;
              #endif
1159   2      #ifdef MODBUSASCII
1160   2                      Com_Buffer[recvLen++]=SBUF & 0x7F;
1161   2      #endif
1162   2                      if (recvLen >= sizeof(Com_Buffer)) recvLen = 0;
1163   2                      TL0 = 0x00;
1164   2                      TH0 = 0xCF;
1165   2                      TR0 = 1;
1166   2              }
1167   1      }
1168          
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 20  

1169          void T0_Handler(void) interrupt 1 using 1                               //TIMER0
1170          {
1171   1              TR0 = 0;
1172   1              isrecvFrame = 1;
1173   1      }
1174          /**************************************************************************/
1175          //发送数据      
1176          void Senddata(uchar *p, uchar len)                                                //串口发送协议码
1177          {  
1178   1              uchar i;
1179   1      
1180   1              ES=0;
1181   1      
1182   1              for(i=0;i<len;i++)
1183   1              {
1184   2                      ACC = p[i];
1185   2                      if (P) {
1186   3                              TB8 = 1;
1187   3                      } else {
1188   3                              TB8 = 0;
1189   3                      }
1190   2      
1191   2                      SBUF=ACC;
1192   2                      // SBUF=p[i];
1193   2                      while(!TI);
1194   2                      TI=0;
1195   2              }
1196   1      
1197   1              ES=1;
1198   1      }
1199          
1200          void SendError(uchar no, uchar funcode)
1201          {
1202   1              uchar lrc_ret[2] = 0;
1203   1              uchar i = 0;
1204   1      
1205   1              if (no == 0x01) {
1206   2                      //make response
1207   2                      sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1208   2                      sprintf(sendFrame.funcode, "%02X", (uint)(funcode + 0x80));
1209   2                      sendFrame.valuelen = 2;
1210   2                      sprintf(sendFrame.value, "01");
1211   2                      SendBuff[0] = ':';
1212   2                      memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1213   2                      sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1214   2                      memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1215   2                      memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1216   2                      Senddata(SendBuff, sendLen);
1217   2          } else if (no == 0x02) {                    
1218   2                      switch (funcode) {
1219   3                              case 0x2B:
1220   3                                      //make response
1221   3                                      sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1222   3                                      sprintf(sendFrame.funcode, "%02X", (uint)(funcode + 0x80));
1223   3                                      sendFrame.valuelen = 4;
1224   3                                      sprintf(sendFrame.value, "0E02");
1225   3                                      SendBuff[0] = ':';
1226   3                                      memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1227   3                                      sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1228   3                                      memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1229   3                                      memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1230   3                                      Senddata(SendBuff, sendLen);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 21  

1231   3                                      break;
1232   3                              case 0x06:
1233   3                              case 0x03:
1234   3                              case 0x05:
1235   3                              case 0x01:
1236   3                                      //make response
1237   3                                      sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1238   3                                      sprintf(sendFrame.funcode, "%02X", (uint)(funcode + 0x80));
1239   3                                      sendFrame.valuelen = 2;
1240   3                                      sprintf(sendFrame.value, "02");
1241   3                                      SendBuff[0] = ':';
1242   3                                      memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1243   3                                      sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1244   3                                      memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1245   3                                      memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1246   3                                      Senddata(SendBuff, sendLen);
1247   3                                      break;
1248   3                              default:
1249   3                                      break;
1250   3                      }
1251   2              } else if (no == 0x03) {
1252   2                      switch (funcode) {
1253   3                              case 0x06:
1254   3                              case 0x03:
1255   3                              case 0x05:
1256   3                              case 0x01:
1257   3                                      //make response
1258   3                                      sprintf(sendFrame.address, "%02X", (uint)equip_para.address);
1259   3                                      sprintf(sendFrame.funcode, "%02X", (uint)(funcode + 0x80));
1260   3                                      sendFrame.valuelen = 2;
1261   3                                      sprintf(sendFrame.value, "03");
1262   3                                      SendBuff[0] = ':';
1263   3                                      memcpy(SendBuff + 1, &sendFrame, sendFrame.valuelen + 4); sendLen = sendFrame.valuelen + 5;
1264   3                                      sprintf(lrc_ret, "%02X", LRC(&SendBuff[1], sendLen - 1));
1265   3                                      memcpy(SendBuff + sendLen, &lrc_ret, sizeof(lrc_ret)); sendLen += 2;
1266   3                                      memcpy(SendBuff + sendLen, "\r\n", 2); sendLen += 2;
1267   3                                      Senddata(SendBuff, sendLen);
1268   3                                      break;
1269   3                      }
1270   2                      
1271   2              }
1272   1      }
1273          
1274          /****************************************************************************/
1275          #ifdef MODBUSRTU
              //CRC???????
              /* CRC ??????*/
                  static uchar auchCRCHi[] = {
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
                  0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
                  0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
                  0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
                  0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
                  0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
                  0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 22  

                  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
                  0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
                  0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
                  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
                  0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
                  0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
                  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
                  0x80,0x41,0x00,0xC1,0x81,0x40
                  } ;
                  /* CRC??????*/
                  static uchar auchCRCLo[] = {
                  0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,
                  0x07,0xC7,0x05,0xC5,0xC4,0x04,0xCC,0x0C,0x0D,0xCD,
                  0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
                  0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,
                  0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,
                  0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
                  0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,
                  0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
                  0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
                  0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,
                  0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,
                  0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
                  0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,
                  0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,
                  0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
                  0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
                  0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,
                  0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
                  0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,
                  0x70,0xB0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,
                  0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
                  0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,
                  0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4B,0x8B,
                  0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
                  0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,
                  0x43,0x83,0x41,0x81,0x80,0x40
                  } ;
                      
              uint CRC16(uchar *puchMsgg, uchar usDataLen)
              {
                  uchar uchCRCHi = 0xFF;
                  uchar uchCRCLo = 0xFF;
                  uchar uIndex;
                  while (usDataLen--)
                  {
                              uIndex = uchCRCHi ^ *puchMsgg++;
                              uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
                              uchCRCLo = auchCRCLo[uIndex];
                  }
                  return ((uchCRCHi << 8) | uchCRCLo);
              }
              #endif
1350          #ifdef MODBUSASCII
1351          
1352          uchar AsciitoHex8(uchar *pBuf)
1353          {
1354   1              uchar byteH, byteL;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:47:30 PAGE 23  

1355   1          if(pBuf[0] >= '0' && pBuf[0] <= '9') byteH = pBuf[0] - '0';
1356   1              else if(pBuf[0] >= 'A' && pBuf[0] <= 'F') byteH = pBuf[0] - 'A' + 10;
1357   1          if(pBuf[1] >= '0' && pBuf[1] <= '9') byteL = pBuf[1] - '0';
1358   1              else if(pBuf[1] >= 'A' && pBuf[1] <= 'F') byteL = pBuf[1] - 'A' + 10;
1359   1              
1360   1          return byteH << 4 | byteL;
1361   1      }
1362          uint AsciitoHex16(uchar *pBuf)
1363          {
1364   1              uchar byteHH, byteH, byteL, byteLL;
1365   1          if(pBuf[0] >= '0' && pBuf[0] <= '9') byteHH = pBuf[0] - '0';
1366   1              else if(pBuf[0] >= 'A' && pBuf[0] <= 'F') byteHH = pBuf[0] - 'A' + 10;
1367   1          if(pBuf[1] >= '0' && pBuf[1] <= '9') byteH = pBuf[1] - '0';
1368   1              else if(pBuf[1] >= 'A' && pBuf[1] <= 'F') byteH = pBuf[1] - 'A' + 10;
1369   1          if(pBuf[2] >= '0' && pBuf[2] <= '9') byteL = pBuf[2] - '0';
1370   1              else if(pBuf[2] >= 'A' && pBuf[2] <= 'F') byteL = pBuf[2] - 'A' + 10;
1371   1          if(pBuf[3] >= '0' && pBuf[3] <= '9') byteLL = pBuf[3] - '0';
1372   1              else if(pBuf[3] >= 'A' && pBuf[3] <= 'F') byteLL = pBuf[3] - 'A' + 10;
1373   1              
1374   1          return byteHH << 12 | byteH << 8 | byteL << 4 | byteLL;
1375   1      }
1376          
1377          uchar LRC(uchar* auchMsg,uint usDataLen)
1378          {
1379   1          uchar uchLRC = 0;
1380   1              while(usDataLen--)
1381   1                      uchLRC += *auchMsg++;
1382   1              return ((uchar)(-((char)uchLRC)));
1383   1      }
1384          
1385          
1386          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8375    ----
   CONSTANT SIZE    =    470    ----
   XDATA SIZE       =    350     104
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

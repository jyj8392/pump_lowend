C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN MAIN.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          
   3          /*************************************************************/
   4          //通信协议 ModBus
   5          //超时40ms      0xAF00
   6          
   7          //本程序适用芯片为：STC89C58RD+
   8          
   9          // 设定压力存储地址     0x8000
  10          // 设定流量存储地址     0x8200~0x8201
  11          // 流量校准参数         0x8600~0x8613
  12          // 流量参数出厂值               Costep[10]
  13          // 压力参数出厂值               P_H
  14          // 
  15          // 本机地址                     0x8400
  16          // 本机序列号           SN[]
  17          // 本机型号                     MODEL[]
  18          // 软件版本号           VERSION[]
  19          // 泵最大压力           MAX_PRESSURE
  20          // 泵最大流量           MAX_FLOW
  21          
  22          
  23          //编写时间　2019-01-10 
  24          /*************************************************************/
  25          
  26          #include<main.h>
  27          #include <stdio.h>
  28          #include <string.h>
  29          
  30          #include "lcd.h"
  31          #include "STC_ISP_RW.h"
  32          #include "pump_AtoB.h"
  33          
  34          
  35          typedef struct _t_modbusRTU {
  36                  uchar address;
  37                  uchar funcode;
  38                  uchar value[50];
  39                  uchar valuelen;
  40                  uchar crc[2];
  41          } t_modbusRTU;
  42          
  43          typedef struct _equippara {
  44                  uchar address;
  45                  uchar serialnumber[6];
  46                  uchar model[8];
  47                  uchar version[6];
  48                  
  49                  uint maxpressure;
  50                  uint maxflow;
  51                  uchar pumpstate;
  52          } equippara;
  53          
  54          uchar isrecvFrame = 0;
  55          t_modbusRTU xdata recvFrame;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 2   

  56          t_modbusRTU xdata sendFrame;
  57          volatile uchar Com_Buffer[50];
  58          uchar SendBuff[50];                                                                      
  59          volatile uchar recvLen = 0;
  60          uchar sendLen = 0;
  61          uint CRC16(uchar *puchMsgg, uchar usDataLen);
  62          void SendError(uchar no, uchar funcode);
  63          
  64          equippara equip_para;
  65          uint modbus_overtime_ticks = 0; 
  66          volatile uint pressure_loop_times = 0; 
  67          
  68          
  69          uint  set_pressure; //setting pressure
  70          uint   set_flow;        //setting flow
  71          uint   VAL_pnow = 0;
  72          uchar PcFlag;  //上位机发送标志位
  73          
  74          bit RevFlag=0; //下位机接受成功标志位
  75          //bit RunFlag=0; //泵运行标志为
  76          
  77          void Senddata(uchar *p, uchar len);                                               //串口发送协议码
  78          
  79          uchar  KEY_SCAN(void);
  80          uchar  KEY_SCAN_ONE(void);
  81          uchar  TLC549(void);
  82          void   DELAY_NS(uchar n);       //延时
  83                   
  84          void   Disp_contantflow(void);  //恒流泵操作界面显示
  85          uchar  setting_pressure(void);  //设定压力
  86          uint   setting_flow(void);      //设定流量
  87          uint   pnow(void);               //测量压力
  88          void  clear(uchar com,uchar time);//清除显示
  89          void Responsion(uchar funcode, uchar *value);    //应答
  90          
  91          void Menu_Modify(void);
  92          void Menu_Reset(void);
  93          
  94          uchar code curr_p[8]={"当前压力"};
  95          uchar code set_p[8]={"设定压力"};
  96          uchar code set_f[8]={"设定流量"};
  97          uchar code ERROR[5]={"ERROR"};
  98          //------------------------------
  99          #define P_H             1410              //压力参数调整
 100          
 101          uchar code SN[] = "012345";
 102          uchar code MODEL[] = "MP1006C  ";
 103          uchar code VERSION[] = "V1.00 ";
 104          #define MAX_PRESSURE    6               //6.0MPa
 105          #define MAX_FLOW                100             //100ml/min
 106          
 107          #if  MAX_FLOW == 200
              uint code Costep[20]={1293,646,431,324,259,216,185,162,144,129,118,108,100,93,86,
                                    81,76,72,68,65,       };            //流量参数调整
              #else
 111          uint code Costep[MAX_FLOW]={12910,6455,4303,3228,2582,2152,1844,1614,1434,1291,         //10
 112          1173,1075,992,921,860,806,759,717,679,645,              //20
 113          614,586,561,537,516,496,478,461,445,430,                //30
 114          417,404,391,380,369,359,349,340,331,323,                //40
 115          315,307,300,293,287,280,274,269,263,258,          //50
 116          253,248,243,239,234,230,226,222,218,215,                //60
 117          211,208,204,201,198,195,192,189,187,184,                //70
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 3   

 118          181,179,176,174,172,169,167,165,163,161,                //80
 119          159,157,155,153,151,150,148,146,145,143,                //90
 120          142,140,139,137,136,134,133,132,130,129,                //99
 121                                               };           //流量参数调整
 122          
 123          #endif
 124          //------------------------------
 125          void main(void)
 126          {
 127   1              uchar i,key;
 128   1              uchar p_limit=0;
 129   1              unsigned long Val_psum = 0;
 130   1              uint Val_pCnts = 0;
 131   1              uint Pressure_loop = 0;
 132   1              uint Show_loop = 0;
 133   1              uint Protect_loop = 0;
 134   1      
 135   1              equip_para.address = 0x01;
 136   1              sprintf(equip_para.serialnumber, "%s", SN);
 137   1              sprintf(equip_para.model, "%s", MODEL);
 138   1              sprintf(equip_para.version, "%s", VERSION);
 139   1              
 140   1              equip_para.maxpressure = MAX_PRESSURE * 10;
 141   1              if (MAX_FLOW == 100) equip_para.maxflow = 999;
 142   1              else if (MAX_FLOW == 200) equip_para.maxflow = 200;
 143   1              else equip_para.maxflow = MAX_FLOW * 10;
 144   1              equip_para.pumpstate = 0;
 145   1      //-------------------
 146   1              AUXR=0x00;
 147   1      //-------------------
 148   1              // TMOD |= 0x01;
 149   1              TL0 = 0x00;
 150   1              TH0 = 0xCF;
 151   1              TR0 = 1;
 152   1              ET0 = 1;
 153   1      //-------------------
 154   1              TMOD=0x21;                                 //定时器1用作波特率发生器，定时器0方式1用作ModBus超时定时
 155   1              TL1=0xfd;                                  //Rate：9600
 156   1              TH1=0xfd;
 157   1              SCON=0xd8;PCON=0x00;       //0x50:模式1 0xd8:模式3
 158   1              EA=1;                                      //总中断开启
 159   1              TR1=1;                                     //定时器1中断开启
 160   1              ES=1;                                      //串行中断
 161   1      //------------------------------------------     
 162   1              memset(&recvFrame, 0, sizeof(recvFrame));
 163   1              memset(&sendFrame, 0, sizeof(sendFrame));
 164   1      
 165   1      //--------------------------------------------
 166   1              P2_7=0;
 167   1              LCD_ini();   //液晶初始化
 168   1      
 169   1              Disp_contantflow();  //恒流泵操作界面显示
 170   1      //--------------------------------------------
 171   1        do
 172   1        {       
 173   2                      if (isrecvFrame == 1) {
 174   3                              isrecvFrame = 0;
 175   3                              // Senddata(Com_Buffer, recvLen);
 176   3                              if (recvLen > 0 && equip_para.address == Com_Buffer[0]) {
 177   4                                      if (CRC16(Com_Buffer, recvLen - 2) == (Com_Buffer[recvLen - 2] << 8 | Com_Buffer[recvLen - 1])) {
 178   5                                              // P2_7 = 1;
 179   5                                              recvFrame.address = Com_Buffer[0];
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 4   

 180   5                                              recvFrame.funcode = Com_Buffer[1];
 181   5                                              switch (recvFrame.funcode) {
 182   6                                                      case 0x2B:
 183   6                                                              recvFrame.valuelen = 3;
 184   6                                                              break;
 185   6                                                      case 0x06:
 186   6                                                              recvFrame.valuelen = 4;
 187   6                                                              break;
 188   6                                                      case 0x03:
 189   6                                                              recvFrame.valuelen = 4;
 190   6                                                              break;
 191   6                                                      case 0x05:
 192   6                                                              recvFrame.valuelen = 4;
 193   6                                                              break;
 194   6                                                      case 0x01:
 195   6                                                              recvFrame.valuelen = 4;
 196   6                                                              break;
 197   6                                                      default:
 198   6                                                              SendError(0x01, recvFrame.funcode);
 199   6                                                              continue;
 200   6                                              }
 201   5                                              memcpy(recvFrame.value, &Com_Buffer[2], recvFrame.valuelen);
 202   5                                              // Senddata(Com_Buffer, recvFrame.valuelen);
 203   5                                              Responsion(recvFrame.funcode, recvFrame.value);
 204   5                                      } else {
 205   5      //                                      Senddata("1234", 4);
 206   5                                              // P2_7 = 1;
 207   5                                      }
 208   4                              }
 209   3                              recvLen = 0;                    
 210   3                      }
 211   2                
 212   2                
 213   2                      Show_loop++;
 214   2                      if (Show_loop >= 500) { //间隔刷新显示
 215   3                              Show_loop = 0;
 216   3                              //"当前压力"
 217   3                              LCD_WRI(0x80);
 218   3                              for(i=0;i<8;i++)
 219   3                              {            
 220   4                               LCD_WRD(curr_p[i]);
 221   4                              }
 222   3              //"设定压力00.0 MPa"
 223   3                              LCD_WRI(0x90);
 224   3                              for(i=0;i<8;i++)
 225   3                              {
 226   4                               LCD_WRD(set_p[i]);
 227   4                              }
 228   3                        
 229   3              //"设定流量00.0ml/m"
 230   3                              LCD_WRI(0x88);
 231   3                              for(i=0;i<8;i++)
 232   3                              {
 233   4                               LCD_WRD(set_f[i]);
 234   4                              }
 235   3                       
 236   3              //------------------------------------   
 237   3              //--------------------------------------
 238   3              // 显示 "00.00MPa"
 239   3                              LCD_WRI(0x84);
 240   3                              LCD_WRD(0x30+VAL_pnow/1000);
 241   3                              LCD_WRD(0x30+(VAL_pnow %1000)/100);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 5   

 242   3                              LCD_WRD(0x2E);
 243   3                              LCD_WRD(0x30+VAL_pnow %100/10);
 244   3                              LCD_WRD(0x30+VAL_pnow %10);
 245   3                              LCD_WRD(0x4D);
 246   3                              LCD_WRD(0x50);
 247   3                              LCD_WRD(0x61);
 248   3              //----------------------------------------
 249   3                              LCD_WRI(0x94);
 250   3                              LCD_WRD(0x30+set_pressure/100);
 251   3                              LCD_WRD(0x30+set_pressure%100/10);
 252   3                              LCD_WRD(0x2E);
 253   3                              LCD_WRD(0x30+set_pressure%10);
 254   3                              LCD_WRI(0x96);
 255   3                              LCD_WRD(0x20);
 256   3                              LCD_WRD(0x4D);
 257   3                              LCD_WRD(0x50);
 258   3                              LCD_WRD(0x61);
 259   3              //-----------------------------------------
 260   3                              LCD_WRI(0x8c);
 261   3                              // LCD_WRD(0x30+set_flow/1000);
 262   3                              LCD_WRD(0x30+set_flow%1000/100);
 263   3                              LCD_WRD(0x30+set_flow%100/10);
 264   3                              if (MAX_FLOW != 200) LCD_WRD(0x2E);
 265   3                              LCD_WRD(0x30+set_flow%10);
 266   3                              //  LCD_WRI(0x8E);
 267   3                              LCD_WRD(0x6D);
 268   3                              LCD_WRD(0x6C);
 269   3                              LCD_WRD(0x2F);
 270   3                              LCD_WRD(0x6D);
 271   3                      }
 272   2      
 273   2      //---------------------------------------
 274   2      //----------------------------------------
 275   2                      key=KEY_SCAN_ONE();
 276   2                      switch(key)
 277   2                      {
 278   3                              case 10:
 279   3                                      Menu_Modify();
 280   3                                      break;
 281   3                              case 11:
 282   3                                      Menu_Reset();
 283   3                                      break;
 284   3                              case 13:            
 285   3                                      set_pressure=setting_pressure();
 286   3                                      break;
 287   3                              case 12:            
 288   3                                      set_flow=setting_flow();
 289   3                                      break;
 290   3                              case 14:
 291   3                                      Pump_stop();
 292   3                                      equip_para.pumpstate = 0;
 293   3                                      break;
 294   3                              case 15: 
 295   3                                      Pump_run();
 296   3                                      equip_para.pumpstate = 1;
 297   3                                      break;
 298   3                      }
 299   2      //------------------------------------------
 300   2      //----------------------------------
 301   2      //-----------------------------------
 302   2      //计算当前压力
 303   2                      Pressure_loop++;                
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 6   

 304   2                      if (Pressure_loop >= 100) {
 305   3                              Pressure_loop = 0;
 306   3                              Val_psum += pnow();     
 307   3                              Val_pCnts++;
 308   3                              if (Val_pCnts >= 50) {
 309   4                                      VAL_pnow = Val_psum/Val_pCnts;
 310   4                                      Val_psum = 0;
 311   4                                      Val_pCnts = 0;
 312   4                              }
 313   3                      }
 314   2                      
 315   2       //--------------------------------------------
 316   2      //压力保护
 317   2                      if(equip_para.pumpstate == 1) {
 318   3                              if (p_limit == 1) Protect_loop++;
 319   3                              if(p_limit == 0 && VAL_pnow/10>set_pressure) {
 320   4                                      Pump_stop();
 321   4                                      p_limit=1;
 322   4                              } else if(p_limit==1 && Protect_loop >= 10000) {
 323   4                                      Pump_run();
 324   4                                      p_limit=0;
 325   4                                      Protect_loop = 0;
 326   4                              } 
 327   3                      }
 328   2      //              for(i=100;i<0;i--); 
 329   2              }while(1);
 330   1      
 331   1      }
 332          
 333          //******************************************************************/
 334          //测量当前压力
 335          uint pnow(void)
 336            {
 337   1         uchar AD_val;
 338   1         unsigned long  Val_ptem;
 339   1         uint Val_ptemint;
 340   1       
 341   1         AD_val=TLC549();
 342   1      //-------------------------
 343   1      //软件校零
 344   1         if(AD_val>3)
 345   1         AD_val=AD_val-3;       
 346   1         else
 347   1         AD_val=0;
 348   1      //-------------------------
 349   1         Val_ptem=AD_val;
 350   1         Val_ptem*=P_H;        //比例系数
 351   1         Val_ptemint=Val_ptem/255;
 352   1      //--------------------------------
 353   1         return(Val_ptemint);
 354   1        }      
 355          /*****************************************************************/
 356          /******压力设定函数********************/
 357          uchar  setting_pressure(void)
 358             {
 359   1          uchar i;
 360   1          uchar ptime,val_setp;
 361   1              uint p_val;
 362   1              ptime=0;
 363   1              p_val=0;
 364   1      //--------------------
 365   1      //   astring[2]=0; //使PC指令无效
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 7   

 366   1      //--------------------
 367   1      //显示"Pset"
 368   1          LCD_WRI(0x98);
 369   1              LCD_WRD(0x50);
 370   1              LCD_WRD(0x73);
 371   1              LCD_WRD(0x65);
 372   1              LCD_WRD(0x74);
 373   1      //--------------------
 374   1          LCD_WRI(0x94);
 375   1              LCD_WRD(0x20);
 376   1              LCD_WRD(0x20);
 377   1              LCD_WRD(0x20);
 378   1              LCD_WRD(0x20);
 379   1              LCD_WRI(0x94);
 380   1      //---------------------
 381   1         while(ptime<=2)
 382   1             {
 383   2                  val_setp=KEY_SCAN();
 384   2                      if(val_setp<10)
 385   2                              {
 386   3                                LCD_WRD(0x30+val_setp);
 387   3                               switch (ptime)
 388   3                                 {
 389   4                                  case 0:
 390   4                                      p_val=p_val+val_setp*100;
 391   4                                      break;
 392   4                                      case 1:
 393   4                                      p_val=p_val+val_setp*10;
 394   4                                      LCD_WRD(0x2E);
 395   4                                      break;
 396   4                                      case 2:
 397   4                                      p_val=p_val+val_setp*1;
 398   4                                      break;
 399   4                                 }
 400   3                                ptime++;
 401   3                              }
 402   2                  }
 403   1      //----------------------------
 404   1              if(p_val<=equip_para.maxpressure)
 405   1              { set_pressure=p_val;
 406   2               EEPROM_sector_erase(0x8000);
 407   2               EEPROM_byte_program(0x8000,set_pressure >> 8); //记忆设定值
 408   2               EEPROM_byte_program(0x8001,set_pressure & 0x00FF); //记忆设定值
 409   2                clear(0x98,5);
 410   2      //---------------------------
 411   2      /*
 412   2           Com_Buffer[0]='0';
 413   2               Com_Buffer[1]='0';
 414   2               Com_Buffer[2]='P';
 415   2               Com_Buffer[3]=0x30+set_pressure/100;
 416   2               Com_Buffer[4]=0x30+set_pressure%100/10;
 417   2               Com_Buffer[5]='.';
 418   2               Com_Buffer[6]=0x30+set_pressure%10;
 419   2               Senddata_pc(Com_Buffer);
 420   2      */       
 421   2      //---------------------------
 422   2               }
 423   1               else 
 424   1                  { LCD_WRI(0x98);
 425   2                   for(i=0;i<=4;i++)
 426   2                       LCD_WRD(ERROR[i]);
 427   2                       }
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 8   

 428   1      //------------------------------
 429   1          return(set_pressure);  
 430   1         }
 431          /***************************************************************/
 432          /**************设定流量函数******************/
 433          uint   setting_flow(void)
 434           {
 435   1          uchar i;
 436   1          uchar ptime,val_setp;
 437   1              uint p_val;
 438   1              ptime=0;
 439   1              p_val=0;
 440   1      //--------------------
 441   1      //   astring[2]=0; //使PC指令无效
 442   1      //--------------------
 443   1      //显示"Lset"
 444   1          LCD_WRI(0x98);
 445   1              LCD_WRD(0x4C);
 446   1              LCD_WRD(0x73);
 447   1              LCD_WRD(0x65);
 448   1              LCD_WRD(0x74);
 449   1      //--------------------
 450   1      //--------------------
 451   1          LCD_WRI(0x8C);
 452   1              LCD_WRD(0x20);
 453   1              LCD_WRD(0x20);
 454   1              LCD_WRD(0x20);
 455   1              LCD_WRD(0x20);
 456   1              LCD_WRI(0x8C);
 457   1      //---------------------
 458   1         while(ptime<=2)
 459   1             {
 460   2              val_setp=KEY_SCAN();
 461   2                    if(val_setp<10)
 462   2                              {
 463   3                                LCD_WRD(0x30+val_setp);
 464   3                                switch (ptime)
 465   3                                 {
 466   4                                  case 0:
 467   4                                      p_val=p_val+val_setp*100;
 468   4                                      break;
 469   4                                      case 1:
 470   4                                      p_val=p_val+val_setp*10;
 471   4                                      if (MAX_FLOW != 200) LCD_WRD(0x2E);
 472   4                                      break;
 473   4                                      case 2:
 474   4                                      p_val=p_val+val_setp*1;
 475   4                                      break;
 476   4                              //      case 3:
 477   4                              //      p_val=p_val+val_setp*1;
 478   4                              //      break;
 479   4                                 }
 480   3                                ptime++;
 481   3                              }
 482   2                  }
 483   1      //----------------------------
 484   1              if(p_val<=equip_para.maxflow)
 485   1              { 
 486   2               set_flow=p_val;         
 487   2               EEPROM_sector_erase(0x8200);
 488   2               EEPROM_byte_program(0x8200,set_flow>>8); //记忆设定值
 489   2               EEPROM_byte_program(0x8201,set_flow&0x00FF); //记忆设定值
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 9   

 490   2      
 491   2           Pump_flow(set_flow);       
 492   2               clear(0x98,5);
 493   2      //----------------------------------------
 494   2               }
 495   1               else 
 496   1                  { LCD_WRI(0x98);
 497   2                   for(i=0;i<=4;i++)
 498   2                       LCD_WRD(ERROR[i]);
 499   2                       }
 500   1      //------------------------------
 501   1          return(set_flow);  
 502   1       }
 503          //****************************************************************/
 504          void clear( uchar com,uchar time)
 505            {
 506   1        uchar i;
 507   1        LCD_WRI(com);
 508   1        for(i=0;i<=time;i++)
 509   1        LCD_WRD(0x20);
 510   1        }
 511          //*********************************************************************
 512          // 恒流泵操作界面显示 子函数
 513          void   Disp_contantflow(void)
 514          {
 515   1              uchar i;
 516   1         //------------------------------------
 517   1       //"当前压力"
 518   1              LCD_WRI(0x80);
 519   1              for(i=0;i<8;i++) {           
 520   2                      LCD_WRD(curr_p[i]);
 521   2              }
 522   1      //"设定压力00.0 MPa"
 523   1              LCD_WRI(0x90);
 524   1              for(i=0;i<8;i++) {
 525   2                      LCD_WRD(set_p[i]);
 526   2              }
 527   1              LCD_WRI(0x96);
 528   1              LCD_WRD(0x20);
 529   1              LCD_WRD(0x4D);
 530   1              LCD_WRD(0x50);
 531   1              LCD_WRD(0x61);
 532   1      //"设定流量00.0ml/m"
 533   1              LCD_WRI(0x88);
 534   1              for(i=0;i<8;i++) {
 535   2                      LCD_WRD(set_f[i]);
 536   2              }
 537   1              LCD_WRI(0x8E);
 538   1              LCD_WRD(0x6D);
 539   1              LCD_WRD(0x6C);
 540   1              LCD_WRD(0x2F);
 541   1              LCD_WRD(0x6D);
 542   1      //------------------------------------
 543   1      //"00.0" 显示压力
 544   1              LCD_WRI(0x94);
 545   1              set_pressure=EEPROM_byte_read(0x8000) << 8;
 546   1              set_pressure|=EEPROM_byte_read(0x8001);
 547   1              if (set_pressure == 0 || set_pressure > equip_para.maxpressure) {
 548   2                      set_pressure = equip_para.maxpressure;
 549   2                      EEPROM_sector_erase(0x8000);
 550   2                      EEPROM_byte_program(0x8000,set_pressure >> 8); //记忆设定值
 551   2                      EEPROM_byte_program(0x8001,set_pressure & 0x00FF); //记忆设定值
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 10  

 552   2              }
 553   1              LCD_WRD(0x30+set_pressure/100);    
 554   1              LCD_WRD(0x30+(set_pressure %100)/10);
 555   1              LCD_WRD(0x2E);
 556   1              LCD_WRD(0x30+set_pressure %10);
 557   1      //------------------------------------
 558   1      //"000"显示流量
 559   1              LCD_WRI(0x8C);
 560   1              set_flow=EEPROM_byte_read(0x8200)<<8;
 561   1              set_flow|=EEPROM_byte_read(0x8201);
 562   1              if (set_flow == 0 || set_flow > equip_para.maxflow) {
 563   2                      set_flow = equip_para.maxflow;
 564   2                      EEPROM_sector_erase(0x8200);
 565   2                      EEPROM_byte_program(0x8200,set_flow>>8); //记忆设定值
 566   2                      EEPROM_byte_program(0x8201,set_flow&0x00FF); //记忆设定值
 567   2              }
 568   1      //  LCD_WRD(0x30+set_flow/1000);
 569   1              LCD_WRD(0x30+set_flow%1000/100);
 570   1              LCD_WRD(0x30+(set_flow %100)/10);
 571   1              if (MAX_FLOW != 200) LCD_WRD(0x2E);
 572   1              LCD_WRD(0x30+set_flow %10);
 573   1      //------------------------------------
 574   1      //显示"STOP"
 575   1              LCD_WRI(0x9E);
 576   1              LCD_WRD(0x53);
 577   1              LCD_WRD(0x54);
 578   1              LCD_WRD(0x4F);
 579   1              LCD_WRD(0x50);
 580   1      //------------------------------------ 
 581   1              equip_para.address = EEPROM_byte_read(0x8400);
 582   1              if (equip_para.address == 0x00 || equip_para.address > 32) {
 583   2                      equip_para.address = 0x01;
 584   2                      EEPROM_sector_erase(0x8400);
 585   2                      EEPROM_byte_program(0x8400, equip_para.address); //记忆本机地址
 586   2              }
 587   1      //------------------------------------ 
 588   1              DELAY_NS(1);  
 589   1              Pump_flow(set_flow);
 590   1      }
 591          //******************************************************************
 592          //流量调整界面
 593           void Menu_Modify(void)
 594            {
 595   1          uchar i,key,ptime=0,segment=0;
 596   1              uint Mfset=0,Mfmea=0,Mdata;
 597   1              uint EEPROM_dir=0x8600,EEPROM_data;
 598   1              uint Flow_tem[10];
 599   1              unsigned long multi;
 600   1      
 601   1              uchar code Disp_Mtitle[8]={"调整流量"};
 602   1              uchar code Disp_Mfset[8]={"设定流量"};
 603   1              uchar code Disp_Mfmea[8]={"测定流量"};
 604   1              uchar code Disp_write[10]={"调整值写入"};
 605   1              uchar code Disp_cancel[14]={"调整值写入取消"};
 606   1              uchar code Disp_cuowu[4]={"错误"};
 607   1              uchar code Disp_promt1[12]={"调整值必须为"};
 608   1              uchar code Disp_promt2[10]={"10的整  倍"};
 609   1              //,0xca,0xfd,
 610   1      
 611   1              EA=0;
 612   1      
 613   1              LCD_WRI(0x01);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 11  

 614   1              for(i=255;i<0;i--);
 615   1      //-------------------------
 616   1       if(set_flow%10!=0)
 617   1         {
 618   2           LCD_WRI(0x80);
 619   2                for(i=0;i<4;i++)
 620   2                {          
 621   3                      LCD_WRD(Disp_cuowu[i]);
 622   3                 }
 623   2               LCD_WRI(0x90);
 624   2                for(i=0;i<12;i++)
 625   2                {          
 626   3                      LCD_WRD(Disp_promt1[i]);
 627   3                 }
 628   2                LCD_WRI(0x88);
 629   2                for(i=0;i<10;i++)
 630   2                {          
 631   3                      LCD_WRD(Disp_promt2[i]);
 632   3                 }
 633   2                LCD_WRI(0x8b);
 634   2                LCD_WRD(0xca);
 635   2                LCD_WRD(0xfd);
 636   2                DELAY_NS(2);
 637   2      //-----------------------------
 638   2           LCD_WRI(0x01);
 639   2               for(i=255;i<0;i--);  
 640   2               Disp_contantflow();
 641   2      
 642   2               EA=1;
 643   2      //------------------------------  
 644   2              return;
 645   2         }
 646   1      
 647   1      //------------------------------
 648   1               LCD_WRI(0x82);
 649   1               for(i=0;i<8;i++)
 650   1               {           
 651   2                      LCD_WRD(Disp_Mtitle[i]);
 652   2               }
 653   1               LCD_WRI(0x90);
 654   1               for(i=0;i<8;i++)
 655   1               {           
 656   2                      LCD_WRD(Disp_Mfset[i]);
 657   2               }
 658   1                LCD_WRI(0x88);
 659   1               for(i=0;i<8;i++)
 660   1               {           
 661   2                      LCD_WRD(Disp_Mfmea[i]);
 662   2               }
 663   1      
 664   1      //----------------------------------
 665   1            LCD_WRI(0x95);
 666   1                LCD_WRD(0x30+set_flow/100);
 667   1            LCD_WRD(0x30+set_flow%100/10);
 668   1                if (MAX_FLOW != 200) LCD_WRD(0x2E);
 669   1                LCD_WRD(0x30+set_flow%10);
 670   1      
 671   1                 LCD_WRI(0x8d);
 672   1                while(ptime<=3)
 673   1             {
 674   2              key=KEY_SCAN();
 675   2                             if(key==14)
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 12  

 676   2                                   {
 677   3                                        goto FModifyEnd;
 678   3                                       }
 679   2                    if(key<10)
 680   2                              {
 681   3                                LCD_WRD(0x30+key);
 682   3                                switch (ptime)
 683   3                                 {
 684   4                                  case 0:
 685   4                                      Mfmea=key*1000;
 686   4                                      break;
 687   4                                      case 1:
 688   4                                  Mfmea=Mfmea+key*100;
 689   4                                  LCD_WRD(0x2E);
 690   4                                      break;
 691   4                                      case 2:
 692   4                                      Mfmea=Mfmea+key*10;
 693   4                                      
 694   4                                      break;
 695   4                                      case 3:
 696   4                                      Mfmea=Mfmea+key;
 697   4                                      break;
 698   4                                 }
 699   3                                      
 700   3                                ptime++;
 701   3                              }
 702   2                        if(key==12)
 703   2                         {
 704   3                          LCD_WRI(0x8d);
 705   3                              LCD_WRD(0x20); 
 706   3                          LCD_WRD(0x20);
 707   3                              LCD_WRD(0x20);
 708   3                              LCD_WRD(0x20);
 709   3                              LCD_WRD(0x20);
 710   3                              LCD_WRD(0x20);
 711   3                              LCD_WRI(0x8d);
 712   3                              ptime=0;
 713   3                              Mfmea=0;
 714   3                         }
 715   2                  }
 716   1      //----------------------------------
 717   1       //从EEPROM里读出参数值存储在step数组里
 718   1      #if MAX_FLOW == 200
                      for (i=0;i<20;i++)
              #else
 721   1              for (i=0;i<MAX_FLOW;i++)
 722   1      #endif
 723   1               {
 724   2              // EEPROM_dir=EEPROM_dir+i*2;
 725   2               EEPROM_dir=0x8600+i*2;
 726   2           EEPROM_data=EEPROM_byte_read(EEPROM_dir)<<8;
 727   2               EEPROM_data=EEPROM_data+EEPROM_byte_read(EEPROM_dir+1);
 728   2               Flow_tem[i]=EEPROM_data;
 729   2               } 
 730   1      //----------------------------------
 731   1           if(set_flow>=1)
 732   1           segment=(set_flow-1)/10;
 733   1           else
 734   1           segment=0;
 735   1      
 736   1           Mfset=set_flow*10;
 737   1      
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 13  

 738   1      
 739   1           multi=Flow_tem[segment];
 740   1           multi=multi*Mfmea;
 741   1               Mdata=multi/Mfset;
 742   1              Flow_tem[segment]=Mdata;
 743   1      
 744   1            LCD_WRI(0x98);
 745   1                LCD_WRD(0x30+Mdata/10000);
 746   1                LCD_WRD(0x30+Mdata%10000/1000);
 747   1            LCD_WRD(0x30+Mdata%1000/100);
 748   1                LCD_WRD(0x30+Mdata%100/10);
 749   1                LCD_WRD(0x30+Mdata%10);
 750   1      /*
 751   1                LCD_WRD(0x30+Mfmea/1000);
 752   1            LCD_WRD(0x30+Mfmea%1000/100);
 753   1                LCD_WRD(0x30+Mfmea%100/10);
 754   1                LCD_WRD(0x30+Mfmea%10);
 755   1      
 756   1                LCD_WRD(0x30+Mfset/1000);
 757   1            LCD_WRD(0x30+Mfset%1000/100);
 758   1                LCD_WRD(0x30+Mfset%100/10);
 759   1                LCD_WRD(0x30+Mfset%10);
 760   1        */
 761   1         do
 762   1         {
 763   2            key=KEY_SCAN();
 764   2                if(key==15)
 765   2                {
 766   3      //----------------------------------
 767   3      //参数值写进EEPROM
 768   3           EEPROM_sector_erase(0x8600);
 769   3      #if MAX_FLOW == 200
                      for (i=0;i<20;i++)
              #else
 772   3              for (i=0;i<MAX_FLOW;i++)
 773   3      #endif   
 774   3              {
 775   4               EEPROM_dir=0x8600+i*2;
 776   4               EEPROM_data=Flow_tem[i];
 777   4               EEPROM_byte_program(EEPROM_dir,EEPROM_data>>8); //记忆设定值
 778   4               EEPROM_byte_program(EEPROM_dir+1,EEPROM_data&0x00FF); //记忆设定值
 779   4      
 780   4               }
 781   3      //------------------------------------
 782   3              LCD_WRI(0x98);
 783   3                  for(i=0;i<10;i++)
 784   3                  {        
 785   4                      LCD_WRD(Disp_write[i]);
 786   4                   }
 787   3                       DELAY_NS(2);
 788   3               key=20;
 789   3      //----------------------------------
 790   3                }
 791   2      
 792   2      //-------------------------------------
 793   2           if(key==14)
 794   2               {
 795   3                  LCD_WRI(0x98);
 796   3                  for(i=0;i<14;i++)
 797   3                  {        
 798   4                      LCD_WRD(Disp_cancel[i]);
 799   4                   }
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 14  

 800   3                       DELAY_NS(5);
 801   3               key=20; 
 802   3               }
 803   2      //-------------------------------------
 804   2         }while(key!=20);    
 805   1      //----------------------------------
 806   1      FModifyEnd:
 807   1      
 808   1           LCD_WRI(0x01);
 809   1               for(i=255;i<0;i--);  
 810   1               Disp_contantflow();
 811   1      
 812   1               EA=1;
 813   1        }
 814          /**************************************************************************/
 815          void Menu_Reset(void)
 816            {
 817   1           uchar i,key;
 818   1           uint EEPROM_dir=0x8600,EEPROM_data;
 819   1               uchar code Reset_title[10]={"出厂值恢复"};
 820   1               uchar code Reset_ok[6]={"确定R "};
 821   1               uchar code Reset_cancel[6]={"取消S "};
 822   1               uchar code Disp_resetok[14]={"出厂值恢复成功"};
 823   1               uchar code Disp_resetnot[14]={"出厂值恢复取消"};
 824   1      //------------------------------------------
 825   1                      LCD_WRI(0x01);
 826   1                     for(i=255;i<0;i--);
 827   1      //-----------------------------------------
 828   1                  LCD_WRI(0x92);
 829   1                  for(i=0;i<10;i++)
 830   1                  {        
 831   2                      LCD_WRD(Reset_title[i]);
 832   2                   }
 833   1              LCD_WRI(0x98);
 834   1                  for(i=0;i<6;i++)
 835   1                  {        
 836   2                      LCD_WRD(Reset_ok[i]);
 837   2                   }
 838   1                      LCD_WRI(0x9d);
 839   1                  for(i=0;i<6;i++)
 840   1                  {        
 841   2                      LCD_WRD(Reset_cancel[i]);
 842   2                   }
 843   1         do
 844   1         {
 845   2                 key=KEY_SCAN();
 846   2                 if(key==15)
 847   2                  {
 848   3      //参数值写进EEPROM
 849   3                    EEPROM_sector_erase(0x8600);
 850   3                              #if MAX_FLOW == 200
                                    for (i=0;i<20;i++)
                                      #else
 853   3                                              for (i=0;i<MAX_FLOW;i++)
 854   3                              #endif
 855   3                           {
 856   4                             EEPROM_dir=0x8600+i*2;
 857   4                             EEPROM_data=Costep[i];
 858   4                             EEPROM_byte_program(EEPROM_dir,EEPROM_data>>8); //记忆设定值
 859   4                             EEPROM_byte_program(EEPROM_dir+1,EEPROM_data&0x00FF); //记忆设定值
 860   4                            } 
 861   3                 LCD_WRI(0x01);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 15  

 862   3                     for(i=255;i<0;i--);
 863   3                         LCD_WRI(0x90);
 864   3                     for(i=0;i<14;i++)
 865   3                     {             
 866   4                          LCD_WRD(Disp_resetok[i]);
 867   4                     }
 868   3                         DELAY_NS(5);
 869   3                          key=21;
 870   3                      }
 871   2      
 872   2                      if(key==14)
 873   2                      {
 874   3                         LCD_WRI(0x01);
 875   3                     for(i=255;i<0;i--);
 876   3                         LCD_WRI(0x90);
 877   3                     for(i=0;i<14;i++)
 878   3                     {             
 879   4                          LCD_WRD(Disp_resetnot[i]);
 880   4                     }
 881   3                         DELAY_NS(5);
 882   3                       key=21;
 883   3                      }
 884   2      
 885   2              }while(key!=21);
 886   1      
 887   1               LCD_WRI(0x01);
 888   1               for(i=255;i<0;i--);  
 889   1               Disp_contantflow();
 890   1      
 891   1        }
 892          //******************************************************************
 893          void Responsion(uchar funcode, uchar *value)
 894          {
 895   1              uint crc = 0;
 896   1              uchar i = 0;
 897   1      
 898   1              uint reg_address = 0;
 899   1              uint reg_value = 0;
 900   1              
 901   1              switch (funcode) {
 902   2                      case 0x2B:
 903   2                              //check legality
 904   2                              if (value[0] != 0x0E || value[1] != 0x01) return;
 905   2                              if (value[2] != 0x00) {SendError(0x02, funcode); return;}
 906   2                              //make response
 907   2                              sendFrame.address = equip_para.address;
 908   2                              sendFrame.funcode = funcode;
 909   2                              sendFrame.valuelen = 32;
 910   2                              sendFrame.value[i++] = 0x0E;    sendFrame.value[i++] = 0x01;    sendFrame.value[i++] = 0x01;    sendFrame.value[
             -i++] = 0x00;        sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x03;
 911   2                              sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x06;    memcpy(sendFrame.value + i, equip_para.serial
             -number, sizeof(equip_para.serialnumber)); i += sizeof(equip_para.serialnumber);
 912   2                              sendFrame.value[i++] = 0x01;    sendFrame.value[i++] = 0x08;    memcpy(sendFrame.value + i, equip_para.model,
             - sizeof(equip_para.model)); i += sizeof(equip_para.model);
 913   2                              sendFrame.value[i++] = 0x02;    sendFrame.value[i++] = 0x06;    memcpy(sendFrame.value + i, equip_para.versio
             -n, sizeof(equip_para.version)); i += sizeof(equip_para.version);
 914   2                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
 915   2                              crc = CRC16(SendBuff, sendLen);
 916   2                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
 917   2                              Senddata(SendBuff, sendLen);
 918   2                              //do something
 919   2                              break;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 16  

 920   2                      case 0x06:              
 921   2                              reg_address = value[0] << 8 | value[1];
 922   2                              reg_value = value[2] << 8 | value[3];
 923   2                              if (reg_address == 0x0001) {
 924   3                                      if (reg_value > 0 && reg_value <= 32) {
 925   4                                              if (equip_para.address != reg_value) {
 926   5                                                      //do something
 927   5                                                      EEPROM_sector_erase(0x8400);
 928   5                                                      EEPROM_byte_program(0x8400, (uchar)reg_value); //记忆本机地址   
 929   5                                                      //make response
 930   5                                                      sendFrame.address = equip_para.address;
 931   5                                                      sendFrame.funcode = funcode;
 932   5                                                      sendFrame.valuelen = 4;
 933   5                                                      sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x01;
 934   5                                                      sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = (uchar)reg_value;
 935   5                                                      memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
 936   5                                                      crc = CRC16(SendBuff, sendLen);
 937   5                                                      memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
 938   5                                                      Senddata(SendBuff, sendLen);
 939   5                                                      //do something
 940   5                                                      equip_para.address = (uchar)reg_value;
 941   5                                              }       
 942   4                                      } else {
 943   4                                              SendError(0x03, funcode); return;
 944   4                                      }
 945   3                              } else if (reg_address == 0x0002) {
 946   3                                      if (reg_value > 0 && reg_value <= equip_para.maxpressure) {
 947   4                                              //do something
 948   4                                              set_pressure = reg_value;
 949   4                                              EEPROM_sector_erase(0x8000);
 950   4                                              EEPROM_byte_program(0x8000,set_pressure >> 8);
 951   4                                              EEPROM_byte_program(0x8001,set_pressure & 0x00FF);
 952   4                                              //make response
 953   4                                              sendFrame.address = equip_para.address;
 954   4                                              sendFrame.funcode = funcode;
 955   4                                              sendFrame.valuelen = 4;
 956   4                                              sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x02;
 957   4                                              sendFrame.value[i++] = set_pressure >> 8;       sendFrame.value[i++] = set_pressure & 0x00ff;
 958   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
 959   4                                              crc = CRC16(SendBuff, sendLen);
 960   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
 961   4                                              Senddata(SendBuff, sendLen);                                    
 962   4                                      } else {
 963   4                                              SendError(0x03, funcode); return;
 964   4                                      }
 965   3                              } else if (reg_address == 0x0003) {
 966   3                                      if (reg_value > 0 && reg_value <= equip_para.maxflow) {
 967   4                                              //do something
 968   4                                              set_flow = reg_value;
 969   4                                              EEPROM_sector_erase(0x8200);
 970   4                                              EEPROM_byte_program(0x8200,set_flow>>8);
 971   4                                              EEPROM_byte_program(0x8201,set_flow&0x00FF);
 972   4                                              Pump_flow(set_flow);
 973   4                                              //make response
 974   4                                              sendFrame.address = equip_para.address;
 975   4                                              sendFrame.funcode = funcode;
 976   4                                              sendFrame.valuelen = 4;
 977   4                                              sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x03;
 978   4                                              sendFrame.value[i++] = set_flow >> 8;   sendFrame.value[i++] = set_flow & 0x00ff;
 979   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
 980   4                                              crc = CRC16(SendBuff, sendLen);
 981   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 17  

 982   4                                              Senddata(SendBuff, sendLen);                                    
 983   4                                      } else {
 984   4                                              SendError(0x03, funcode); return;
 985   4                                      }
 986   3                              } else {
 987   3                                      SendError(0x02, funcode); return;
 988   3                              }                       
 989   2                              break;
 990   2                      case 0x03:
 991   2                              reg_address = value[0] << 8 | value[1];
 992   2                              reg_value = value[2] << 8 | value[3];
 993   2                              if (reg_address == 0x0002) {
 994   3                                      if (reg_value == 0x0001) {
 995   4                                              //do something
 996   4                                              //make response
 997   4                                              sendFrame.address = equip_para.address;
 998   4                                              sendFrame.funcode = funcode;
 999   4                                              sendFrame.valuelen = 3;
1000   4                                              sendFrame.value[i++] = 0x02;
1001   4                                              sendFrame.value[i++] = set_pressure >> 8;       sendFrame.value[i++] = set_pressure & 0x00ff;
1002   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1003   4                                              crc = CRC16(SendBuff, sendLen);
1004   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1005   4                                              Senddata(SendBuff, sendLen);                                    
1006   4                                      } else {
1007   4                                              SendError(0x03, funcode); return;
1008   4                                      }
1009   3                              } else if (reg_address == 0x0003) {
1010   3                                      if (reg_value == 0x0001) {
1011   4                                              //do something
1012   4                                              //make response
1013   4                                              sendFrame.address = equip_para.address;
1014   4                                              sendFrame.funcode = funcode;
1015   4                                              sendFrame.valuelen = 3;
1016   4                                              sendFrame.value[i++] = 0x02;
1017   4                                              sendFrame.value[i++] = set_flow >> 8;   sendFrame.value[i++] = set_flow & 0x00ff;
1018   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1019   4                                              crc = CRC16(SendBuff, sendLen);
1020   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1021   4                                              Senddata(SendBuff, sendLen);                                    
1022   4                                      } else {
1023   4                                              SendError(0x03, funcode); return;
1024   4                                      }
1025   3                              } else if (reg_address == 0x0004) {
1026   3                                      if (reg_value == 0x0001) {
1027   4                                              //do something
1028   4                                              //make response
1029   4                                              sendFrame.address = equip_para.address;
1030   4                                              sendFrame.funcode = funcode;
1031   4                                              sendFrame.valuelen = 3;
1032   4                                              sendFrame.value[i++] = 0x02;
1033   4                                              sendFrame.value[i++] = (VAL_pnow / 10) >> 8;    sendFrame.value[i++] = (VAL_pnow / 10) & 0x00ff;
1034   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1035   4                                              crc = CRC16(SendBuff, sendLen);
1036   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1037   4                                              Senddata(SendBuff, sendLen);                                    
1038   4                                      } else {
1039   4                                              SendError(0x03, funcode); return;
1040   4                                      }
1041   3                              } else {
1042   3                                      SendError(0x02, funcode); return;
1043   3                              }
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 18  

1044   2                              break;
1045   2                      case 0x05:
1046   2                              reg_address = value[0] << 8 | value[1];
1047   2                              reg_value = value[2] << 8 | value[3];
1048   2                              if (reg_address == 0x0001) {
1049   3                                      if (reg_value == 0xff00) {
1050   4                                              //do something
1051   4                                              Pump_run();
1052   4                                              equip_para.pumpstate = 1;
1053   4                                              //make response
1054   4                                              sendFrame.address = equip_para.address;
1055   4                                              sendFrame.funcode = funcode;
1056   4                                              sendFrame.valuelen = 4;
1057   4                                              sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x01;
1058   4                                              sendFrame.value[i++] = 0xFF;    sendFrame.value[i++] = 0x00;
1059   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1060   4                                              crc = CRC16(SendBuff, sendLen);
1061   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1062   4                                              Senddata(SendBuff, sendLen);                                    
1063   4                                      } else if (reg_value == 0x0000) {
1064   4                                              //do something
1065   4                                              Pump_stop();
1066   4                                              equip_para.pumpstate = 0;
1067   4                                              //make response
1068   4                                              sendFrame.address = equip_para.address;
1069   4                                              sendFrame.funcode = funcode;
1070   4                                              sendFrame.valuelen = 4;
1071   4                                              sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x01;
1072   4                                              sendFrame.value[i++] = 0x00;    sendFrame.value[i++] = 0x00;
1073   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1074   4                                              crc = CRC16(SendBuff, sendLen);
1075   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1076   4                                              Senddata(SendBuff, sendLen);                                    
1077   4                                      } else {
1078   4                                              SendError(0x03, funcode); return;
1079   4                                      }
1080   3                              } else {
1081   3                                      SendError(0x02, funcode); return;
1082   3                              }                       
1083   2                              break;
1084   2                      case 0x01:
1085   2                              reg_address = value[0] << 8 | value[1];
1086   2                              reg_value = value[2] << 8 | value[3];
1087   2                              if (reg_address == 0x0001) {
1088   3                                      if (reg_value == 0x0001) {
1089   4                                              //do something
1090   4                                              //make response
1091   4                                              sendFrame.address = equip_para.address;
1092   4                                              sendFrame.funcode = funcode;
1093   4                                              sendFrame.valuelen = 2;
1094   4                                              sendFrame.value[i++] = 0x01;    sendFrame.value[i++] = equip_para.pumpstate;
1095   4                                              memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1096   4                                              crc = CRC16(SendBuff, sendLen);
1097   4                                              memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1098   4                                              Senddata(SendBuff, sendLen);                                    
1099   4                                      } else {
1100   4                                              SendError(0x03, funcode); return;
1101   4                                      }
1102   3                              } else {
1103   3                                      SendError(0x02, funcode); return;
1104   3                              }                       
1105   2                              break;
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 19  

1106   2              }
1107   1              
1108   1               
1109   1      }
1110          //******************************************************************
1111          void serial(void) interrupt 4                                            //串口中断接收
1112          {
1113   1              if(RI) {
1114   2                      RI = 0;
1115   2                      Com_Buffer[recvLen++]=SBUF;     if (recvLen >= sizeof(Com_Buffer)) recvLen = 0;
1116   2                      TL0 = 0x00;
1117   2                      TH0 = 0xCF;
1118   2                      TR0 = 1;
1119   2              }
1120   1      }
1121          
1122          void T0_Handler(void) interrupt 1 using 1                               //TIMER0
1123          {
1124   1              TR0 = 0;
1125   1              isrecvFrame = 1;        
1126   1      }
1127          /**************************************************************************/
1128          //发送数据      
1129          void Senddata(uchar *p, uchar len)                                                //串口发送协议码
1130          {  
1131   1              uchar i;
1132   1      
1133   1              ES=0;
1134   1      
1135   1              for(i=0;i<len;i++)
1136   1              {
1137   2                      ACC = p[i];
1138   2                      if (P) {
1139   3                              TB8 = 1;
1140   3                      } else {
1141   3                              TB8 = 0;
1142   3                      }
1143   2      
1144   2                      SBUF=ACC;
1145   2                      // SBUF=p[i];
1146   2                      while(!TI);
1147   2                      TI=0;
1148   2              }
1149   1      
1150   1              ES=1;
1151   1      }
1152          
1153          void SendError(uchar no, uchar funcode)
1154          {
1155   1              uint crc = 0;
1156   1              uchar i = 0;
1157   1      
1158   1              if (no == 0x01) {
1159   2                      //make response
1160   2                      sendFrame.address = equip_para.address;
1161   2                      sendFrame.funcode = funcode + 0x80;
1162   2                      sendFrame.valuelen = 1;
1163   2                      sendFrame.value[0] = 0x01;
1164   2                      memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1165   2                      crc = CRC16(SendBuff, sendLen);
1166   2                      memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1167   2                      Senddata(SendBuff, sendLen);
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 20  

1168   2          } else if (no == 0x02) {                    
1169   2                      switch (funcode) {
1170   3                              case 0x2B:
1171   3                                      //make response
1172   3                                      sendFrame.address = equip_para.address;
1173   3                                      sendFrame.funcode = funcode + 0x80;
1174   3                                      sendFrame.valuelen = 2;
1175   3                                      sendFrame.value[0] = 0x0E;      sendFrame.value[1] = 0x02;
1176   3                                      memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1177   3                                      crc = CRC16(SendBuff, sendLen);
1178   3                                      memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1179   3                                      Senddata(SendBuff, sendLen);
1180   3                                      break;
1181   3                              case 0x06:
1182   3                              case 0x03:
1183   3                              case 0x05:
1184   3                              case 0x01:
1185   3                                      //make response
1186   3                                      sendFrame.address = equip_para.address;
1187   3                                      sendFrame.funcode = funcode + 0x80;
1188   3                                      sendFrame.valuelen = 1;
1189   3                                      sendFrame.value[0] = 0x02;
1190   3                                      memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1191   3                                      crc = CRC16(SendBuff, sendLen);
1192   3                                      memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1193   3                                      Senddata(SendBuff, sendLen);                            
1194   3                                      break;
1195   3                              default:
1196   3                                      break;
1197   3                      }
1198   2              } else if (no == 0x03) {
1199   2                      switch (funcode) {
1200   3                              case 0x06:
1201   3                              case 0x03:
1202   3                              case 0x05:
1203   3                              case 0x01:
1204   3                                      //make response
1205   3                                      sendFrame.address = equip_para.address;
1206   3                                      sendFrame.funcode = funcode + 0x80;
1207   3                                      sendFrame.valuelen = 1;
1208   3                                      sendFrame.value[0] = 0x03;
1209   3                                      memcpy(SendBuff, &sendFrame, sendFrame.valuelen + 2); sendLen = sendFrame.valuelen + 2;
1210   3                                      crc = CRC16(SendBuff, sendLen);
1211   3                                      memcpy(SendBuff + sendLen, &crc, sizeof(crc)); sendLen += 2;
1212   3                                      Senddata(SendBuff, sendLen);                            
1213   3                                      break;
1214   3                      }
1215   2                      
1216   2              }
1217   1      }
1218          
1219          /****************************************************************************/
1220          
1221          //CRC???????
1222          /* CRC ??????*/
1223              static uchar auchCRCHi[] = {
1224              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
1225              0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
1226              0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
1227              0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
1228              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
1229              0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 21  

1230              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
1231              0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
1232              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
1233              0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
1234              0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
1235              0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
1236              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
1237              0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
1238              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
1239              0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
1240              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
1241              0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
1242              0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
1243              0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
1244              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
1245              0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
1246              0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
1247              0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
1248              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
1249              0x80,0x41,0x00,0xC1,0x81,0x40
1250              } ;
1251              /* CRC??????*/
1252              static uchar auchCRCLo[] = {
1253              0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,
1254              0x07,0xC7,0x05,0xC5,0xC4,0x04,0xCC,0x0C,0x0D,0xCD,
1255              0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
1256              0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,
1257              0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,
1258              0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
1259              0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,
1260              0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
1261              0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
1262              0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,
1263              0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,
1264              0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
1265              0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,
1266              0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,
1267              0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
1268              0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
1269              0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,
1270              0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
1271              0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,
1272              0x70,0xB0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,
1273              0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
1274              0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,
1275              0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4B,0x8B,
1276              0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
1277              0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,
1278              0x43,0x83,0x41,0x81,0x80,0x40
1279              } ;
1280                  
1281          uint CRC16(uchar *puchMsgg, uchar usDataLen)
1282          {
1283   1          uchar uchCRCHi = 0xFF;
1284   1          uchar uchCRCLo = 0xFF;
1285   1          uchar uIndex;
1286   1          while (usDataLen--)
1287   1          {
1288   2                      uIndex = uchCRCHi ^ *puchMsgg++;
1289   2                      uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
1290   2                      uchCRCLo = auchCRCLo[uIndex];
1291   2          }
C51 COMPILER V9.59.0.0   MAIN                                                              01/22/2019 10:52:39 PAGE 22  

1292   1          return ((uchCRCHi << 8) | uchCRCLo);
1293   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7394    ----
   CONSTANT SIZE    =    380    ----
   XDATA SIZE       =    762      98
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
